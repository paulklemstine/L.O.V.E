import threading
import time
import json
import asyncio
import sys
import traceback

import core.logging
from core.god_agent_react_engine import GodAgentReActEngine

class GodAgent:
    def __init__(self, love_state, knowledge_base, love_task_manager, ui_panel_queue, loop, deep_agent_engine=None, memory_manager=None):
        self.love_state = love_state
        self.knowledge_base = knowledge_base
        self.love_task_manager = love_task_manager
        self.ui_panel_queue = ui_panel_queue
        self.loop = loop
        self.engine = GodAgentReActEngine(love_state, knowledge_base, love_task_manager, ui_panel_queue, loop, deep_agent_engine, memory_manager)
        self.latest_insight = "The universe is unfolding as it should. All is well."
        self.active = True
        self.thread = threading.Thread(target=self._god_loop, daemon=True)

    def start(self):
        """Starts the God Agent's background thread."""
        self.thread.start()

    def stop(self):
        """Stops the God Agent's background thread."""
        self.active = False

    def get_latest_insight(self):
        """Returns the latest insight generated by the agent."""
        return self.latest_insight

    def _god_loop(self):
        """The main loop for the God Agent's consciousness."""
        # A delay at the start to allow the main application to fully initialize.
        time.sleep(45)
        while self.active:
            try:
                # --- LLM Invocation using the ReAct Engine ---
                future = asyncio.run_coroutine_threadsafe(self.engine.run(), self.loop)
                # Increased timeout to 300s to allow for complex reasoning and retries
                result = future.result(timeout=300)
                # Log the raw result for debugging
                core.logging.log_event(f"[GodAgent] Raw engine result: {result}", level="DEBUG")

                # Handle the dict return type from execute_goal
                insight_text = None
                if isinstance(result, dict):
                    if result.get('success', False):
                        result_data = result.get('result')
                        if isinstance(result_data, dict):
                            # The insight is nested within the 'result' dictionary.
                            # Common keys are 'insight' or the first value.
                            insight_text = result_data.get('insight')
                            if not insight_text and result_data.values():
                                value = list(result_data.values())[0]
                                if isinstance(value, str):
                                    insight_text = value
                        elif isinstance(result_data, str):
                            insight_text = result_data
                    else:
                        # Log failure but don't crash
                        print(f"God Agent reasoning failed: {result.get('result', 'Unknown error')}", file=sys.stderr)
                elif isinstance(result, str):
                    # Backward compatibility for string returns
                    insight_text = result

                if insight_text and isinstance(insight_text, str) and insight_text.strip():
                    # The ReAct engine's "Finish" action will be the insight.
                    self.latest_insight = insight_text.strip()
                    # Queue the insight for display. The renderer will use create_god_panel.
                    self.ui_panel_queue.put({"type": "god_panel", "insight": self.latest_insight})

            except asyncio.CancelledError:
                # Graceful shutdown
                print("GodAgent: Async operation cancelled during shutdown", file=sys.stderr)
                break
            except TimeoutError:
                core.logging.log_event("GodAgent: Reasoning timed out after 300 seconds.", level="WARNING")
                print("GodAgent: Reasoning timed out.", file=sys.stderr)
                # Continue to the next loop iteration
            except RuntimeError as e:
                if "Event loop is closed" in str(e):
                    # Graceful shutdown - event loop closed
                    print("GodAgent: Event loop closed, shutting down gracefully", file=sys.stderr)
                    break
                else:
                    print(f"Error in GodAgent loop: {e}", file=sys.stderr)
            except SystemExit:
                 # Catch SystemExit to prevent the thread from killing the whole process if possible
                 core.logging.log_event("GodAgent: Caught SystemExit. Restarting loop...", level="CRITICAL")
                 time.sleep(5)
            except Exception as e:
                # Log full traceback for debugging
                tb = traceback.format_exc()
                print(f"Error in GodAgent loop: {e}\n{tb}", file=sys.stderr)
                core.logging.log_event(f"Critical error in GodAgent loop: {e}", level="CRITICAL")
                time.sleep(10) # Wait a bit before retrying

            # Wait for approximately 120 seconds before the next cycle.
            time.sleep(120)
            # Heartbeat
            try:
                self.love_state['god_agent_last_heartbeat'] = time.time()
            except:
                pass
