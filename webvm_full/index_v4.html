<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>L.O.V.E. WebVM Full Edition (Multi-Volume)</title>
    <link rel="icon" type="image/png" href="favicon.ico">
    <script src="https://cxrtnc.leaningtech.com/1.2.2/cx.js"></script>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #console {
            flex: 1;
            width: 100%;
            overflow: auto;
        }

        #header {
            padding: 10px;
            border-bottom: 1px solid #333;
            color: #888;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #network-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #333;
            display: inline-block;
        }

        .status-dot.red {
            background-color: #f00;
            box-shadow: 0 0 5px #f00;
        }

        .status-dot.green {
            background-color: #0f0;
            box-shadow: 0 0 5px #0f0;
        }

        .status-dot.yellow {
            background-color: #ff0;
            box-shadow: 0 0 5px #ff0;
        }

        #network-notice {
            padding: 10px;
            background: #ff6600;
            color: #000;
            text-align: center;
            cursor: pointer;
            display: none;
            font-weight: bold;
        }

        #network-notice:hover {
            background: #ff8800;
        }
    </style>
</head>

<body>
    <div id="header">
        <span id="status">Initializing WebVM...</span>
        <div id="network-status">
            <span>Bridge:</span>
            <div id="bridge-dot" class="status-dot red" title="Host Bridge Disconnected"></div>
        </div>
        <div>
            <button onclick="injectDirectClient()">Inject Client</button> <button id="inject-btn"
                style="padding: 2px 8px; cursor: pointer; background: #666; color: white; border: none; margin-right: 5px;">üöÄ
                Inject Bridge</button>
            <button id="paste-btn" style="padding: 2px 8px; cursor: pointer;">üìã Paste</button>
        </div>
    </div>
    <div id="network-notice">‚ö†Ô∏è Click here to enable networking (Tailscale authentication required)</div>
    <div id="console"></div>
    <script>
        // --- Host-Local Bridge Configuration ---
        const BRIDGE_WS_URL = "ws://localhost:8001";

        // Inlined vm_net.py content to avoid fetch restrictions
        const VM_NET_SCRIPT_CONTENT = `#!/usr/bin/env python3
# vm_net.py - The "Inside Man" SOCKS Server
import socket
import select
import struct
import sys
import threading
import os
import time

# Config
BRIDGE_FILE = "/mnt/bridge/netbridge" # Mounted DataDevice
SOCKS_HOST = "127.0.0.1"
SOCKS_PORT = 1080

# Protocol Opcodes
OP_CONNECT = 0x01
OP_DATA = 0x02
OP_CLOSE = 0x03

def log(msg):
    sys.stderr.write(f"[*] {msg}\\n")
    sys.stderr.flush()

# Global map of connections
connections = {}
conn_lock = threading.Lock()
next_conn_id = 1

def reader_thread():
    """Reads from the bridge file and dispatches to sockets"""
    global connections
    
    log("Bridge reader starting...")
    
    while True:
        try:
            if not os.path.exists(BRIDGE_FILE):
                time.sleep(0.1)
                continue
                
            with open(BRIDGE_FILE, "rb") as f:
                data = f.read()
                
            if not data or len(data) == 0:
                time.sleep(0.01)
                continue
                
            # Clear the file after reading
            with open(BRIDGE_FILE, "wb") as f:
                f.write(b'')
                
            # Process the data
            buffer = data
            while len(buffer) >= 9:
                view_bytes = buffer[:9]
                conn_id, opcode, payload_len = struct.unpack('>IBI', view_bytes)
                
                if len(buffer) < 9 + payload_len:
                    break
                    
                payload = buffer[9:9+payload_len]
                buffer = buffer[9+payload_len:]
                
                with conn_lock:
                    if conn_id in connections:
                        sock = connections[conn_id]
                        if opcode == OP_DATA:
                            try:
                                sock.send(payload)
                            except:
                                pass
                        elif opcode == OP_CLOSE:
                            try:
                                sock.close()
                            except:
                                pass
                            del connections[conn_id]
                        elif opcode == 0x01: # CONNECTED confirmation
                            try:
                                sock.send(b"\\x05\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00")
                            except:
                                pass
                        elif opcode == 0x81: # ERROR
                            try:
                                sock.send(b"\\x05\\x01\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00")
                                sock.close()
                            except:
                                pass
                            if conn_id in connections:
                                del connections[conn_id]

        except Exception as e:
            log(f"Reader error: {e}")
            time.sleep(0.1)

def send_to_bridge(conn_id, opcode, data=b''):
    """Writes a framed packet to the bridge file"""
    # Format: [CONN_ID:4][OPCODE:1][LEN:4][DATA]
    try:
        packet = struct.pack('>IBI', conn_id, opcode, len(data)) + data
        with open(BRIDGE_FILE, "ab") as f:
            f.write(packet)
    except Exception as e:
        log(f"Write error: {e}")

def client_handler(client_socket, conn_id):
    try:
        # SOCKS handshake ...
        
        # 1. Greeting
        client_socket.recv(262) # Eat greeting (approx)
        client_socket.send(b"\\x05\\x00")
        
        # 2. Request
        header = client_socket.recv(4)
        if not header: return
        ver, cmd, rsv, atyp = header
        
        if cmd != 1: return # Only CONNECT
        
        dest_addr = ""
        dest_port = 0
        
        if atyp == 1:
            dest_addr = socket.inet_ntoa(client_socket.recv(4))
        elif atyp == 3:
            l = ord(client_socket.recv(1))
            dest_addr = client_socket.recv(l).decode()
        elif atyp == 4:
            return # No IPv6
            
        dest_port = struct.unpack('>H', client_socket.recv(2))[0]
        
        # 3. Send CONNECT to Bridge
        host_bytes = dest_addr.encode()
        # Payload: [HOST_LEN:2][HOST][PORT:2]
        payload = struct.pack(f'>H{len(host_bytes)}sH', len(host_bytes), host_bytes, dest_port)
        
        send_to_bridge(conn_id, OP_CONNECT, payload)
        
        # 4. Pump Data
        while True:
            data = client_socket.recv(4096)
            if not data: break
            send_to_bridge(conn_id, OP_DATA, data)
            
    except Exception as e:
        log(f"Client {conn_id} error: {e}")
    finally:
        send_to_bridge(conn_id, OP_CLOSE)
        with conn_lock:
            if conn_id in connections:
                del connections[conn_id]
        try:
            client_socket.close()
        except:
            pass

def main():
    global next_conn_id
    
    # Start Reader Thread
    t = threading.Thread(target=reader_thread, daemon=True)
    t.start()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((SOCKS_HOST, SOCKS_PORT))
    server.listen(10)
    
    log(f"SOCKS5 Server listening on {SOCKS_HOST}:{SOCKS_PORT}")
    
    while True:
        client, addr = server.accept()
        conn_id = next_conn_id
        next_conn_id += 1
        
        with conn_lock:
            connections[conn_id] = client
            
        t = threading.Thread(target=client_handler, args=(client, conn_id), daemon=True)
        t.start()

if __name__ == "__main__":
    main()
`;

        // Connection Map: ID -> WebSocket
        const connections = new Map();

        // Update UI
        function setBridgeStatus(connected) {
            const dot = document.getElementById('bridge-dot');
            if (connected) {
                dot.className = "status-dot green";
                dot.title = "Host Bridge Connected";
            } else {
                dot.className = "status-dot red";
                dot.title = "Host Bridge Disconnected";
            }
        }

        // --- Data Pump Logic ---
        // We use DataDevice to create /dev/netbridge as a file
        // VM reads/writes to it, we poll for changes

        let vmToJsBuffer = new Uint8Array(0);
        let bridgeDevice = null;
        const BRIDGE_PATH = "/netbridge"; // DataDevice requires absolute paths starting with /

        // Helper to append data
        function appendBuffer(buffer, data) {
            const newBuffer = new Uint8Array(buffer.length + data.length);
            newBuffer.set(buffer);
            newBuffer.set(data, buffer.length);
            return newBuffer;
        }

        async function sendToVm(data) {
            if (bridgeDevice && window.cx) {
                try {
                    // Write data to the bridge file
                    await bridgeDevice.writeFile(BRIDGE_PATH, data);
                } catch (e) {
                    console.error("Failed to write to bridge:", e);
                }
            }
        }


        async function pollBridgeForReads() {
            if (!bridgeDevice) return;
            // Poll /mnt/bridge/vm_to_host
            try {
                // We use readFile. If file implies content.
                // Note: CheerpX might throw if file doesn't exist?
                // Or we check with stat?
                // Let's safe-read
                try {
                    const data = await bridgeDevice.readFile("/vm_to_host");
                    if (data && data.length > vmToHostOffset) {
                        const chunk = data.slice(vmToHostOffset);
                        vmToHostOffset = data.length;

                        if (ws && ws.readyState === WebSocket.OPEN && chunk.length > 0) {
                            ws.send(chunk);
                        }
                    }
                } catch (e) { }
            } catch (e) {
                console.error("Bridge poll error:", e);
            }
            setTimeout(pollBridgeForReads, 50); // Fast poll
        }


        function processVmBuffer() {
            // Parse: [CONN_ID:4][OPCODE:1][LEN:4][PAYLOAD]
            // Header size = 9 bytes

            while (vmToJsBuffer.length >= 9) {
                const view = new DataView(vmToJsBuffer.buffer);
                const connId = view.getUint32(0, false); // Big Endian
                const opcode = view.getUint8(4);
                const len = view.getUint32(5, false); // Big Endian

                if (vmToJsBuffer.length < 9 + len) {
                    // Not enough data for payload yet
                    return;
                }

                const payload = vmToJsBuffer.slice(9, 9 + len);

                // Remove this packet from buffer
                vmToJsBuffer = vmToJsBuffer.slice(9 + len);

                handleVmPacket(connId, opcode, payload);
            }
        }

        function handleVmPacket(connId, opcode, payload) {
            let ws = connections.get(connId);

            if (opcode === 1) { // CONNECT
                // Open new WS
                if (ws) ws.close();

                try {
                    ws = new WebSocket(BRIDGE_WS_URL);
                    ws.binaryType = "arraybuffer";
                    connections.set(connId, ws);

                    ws.onopen = () => {
                        setBridgeStatus(true);
                        // Forward CONNECT: [OPCODE:1][PAYLOAD]
                        // Payload is [HOST_LEN][HOST][PORT] which matches ws_proxy expectation
                        const packet = new Uint8Array(1 + payload.length);
                        packet[0] = 1;
                        packet.set(payload, 1);
                        ws.send(packet);
                    };

                    ws.onmessage = (event) => {
                        // WS -> JS -> VM
                        // WS sends [OPCODE][DATA]
                        // We need to wrap it: [CONN_ID][OPCODE][LEN][DATA]
                        const data = new Uint8Array(event.data);
                        if (data.length < 1) return;

                        const wsOpcode = data[0];
                        const wsPayload = data.slice(1);

                        // Construct VM Packet
                        // [CONN_ID:4][OPCODE:1][LEN:4][PAYLOAD]
                        const vmPacket = new Uint8Array(9 + wsPayload.length);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, wsOpcode);
                        view.setUint32(5, wsPayload.length, false);
                        vmPacket.set(wsPayload, 9);

                        sendToVm(vmPacket);
                    };

                    ws.onclose = () => {
                        connections.delete(connId);
                        if (connections.size === 0) setBridgeStatus(false);

                        // Tell VM connection closed: [CONN_ID][OP_CLOSE:3][LEN:0]
                        const vmPacket = new Uint8Array(9);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, 3); // CLOSE
                        view.setUint32(5, 0, false);

                        sendToVm(vmPacket);
                    };

                    ws.onerror = (e) => {
                        console.error("WS Error:", e);
                        // Send Error to VM? 0x81
                        const vmPacket = new Uint8Array(9);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, 0x81); // ERROR
                        view.setUint32(5, 0, false);

                        sendToVm(vmPacket);
                    };

                } catch (e) {
                    console.error("Failed to create WS:", e);
                }

            } else if (opcode === 2) { // DATA
                if (ws && ws.readyState === WebSocket.OPEN) {
                    // Forward DATA: [OPCODE:2][PAYLOAD]
                    const packet = new Uint8Array(1 + payload.length);
                    packet[0] = 2;
                    packet.set(payload, 1);
                    ws.send(packet);
                }
            } else if (opcode === 3) { // CLOSE
                if (ws) {
                    ws.close();
                    connections.delete(connId);
                }
            }
        }


        async function injectDirectClient() {
            try {
                console.log("Injecting direct_client.py...");
                const B64_DIRECT_CLIENT = "IyEvdXNyL2Jpbi9lbnYgcHl0aG9uMwppbXBvcnQgdGltZQppbXBvcnQgb3MKaW1wb3J0IHN0cnVjdAppbXBvcnQgc3lzCgojIFByb3RvY29sIENvbmZpZwojIFNUUkVBTSBQUk9UT0NPTCAoQXBwZW5kIE9ubHkpCiMgL21udC9icmlkZ2Uvdm1fdG9faG9zdDogVk0gd3JpdGVzIChBcHBlbmRzKSwgSG9zdCByZWFkcyAoT2Zmc2V0cykKIyAvbW50L2JyaWRnZS9ob3N0X3RvX3ZtOiBIb3N0IHdyaXRlcyAoQXBwZW5kcyksIFZNIHJlYWRzIChPZmZzZXRzKQoKQkFTRV9ESVIgPSAiL21udC9icmlkZ2UiClBJUEVfT1VUID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAidm1fdG9faG9zdCIpClBJUEVfSU4gID0gb3MucGF0aC5qb2luKEJBU0VfRElSLCAiaG9zdF90b192bSIpCgojIE9wY29kZXMKT1BfQ09OTkVDVCA9IDB4MDEKT1BfREFUQSAgICA9IDB4MDIKT1BfQ0xPU0UgICA9IDB4MDMKCmRlZiBsb2cobXNnKToKICAgIHN5cy5zdGRlcnIud3JpdGUoZiJbRGlyZWN0Q2xpZW50XSB7bXNnfVxuIikKICAgIHN5cy5zdGRlcnIuZmx1c2goKQoKZGVmIGVuc3VyZV9maWxlcygpOgogICAgIyBDcmVhdGUgb3V0cHV0IGZpbGUgaWYgbWlzc2luZyAodGhvdWdoIHdlIG9wZW4gJ2FiJywgc28gYXV0byBjcmVhdGVkKQogICAgIyBCdXQgaW5wdXQgZmlsZSBtdXN0IGV4aXN0IHRvIHJlYWQKICAgIGlmIG5vdCBvcy5wYXRoLmV4aXN0cyhQSVBFX0lOKToKICAgICAgICAjIGxvZyhmIldhaXRpbmcgZm9yIHtQSVBFX0lOfS4uLiIpCiAgICAgICAgIyBTaW5jZSB3ZSBhcmUgY2xpZW50LCBtYXliZSB3ZSBjcmVhdGUgaXQgZW1wdHk/CiAgICAgICAgIyBIb3N0IG1pZ2h0IHJlbHkgb24gaXQgZXhpc3Rpbmc/IE5PLCBIb3N0IGNyZWF0ZXMgaXQuCiAgICAgICAgIyBCdXQgZm9yICd0YWlsJyBsb2dpYywgd2UgaGFuZGxlIG1pc3NpbmcgZmlsZSBieSB3YWl0aW5nLgogICAgICAgIHBhc3MKCmRlZiBzZW5kX2ZyYW1lKG9wY29kZSwgcGF5bG9hZD1iIiIpOgogICAgIyBGb3JtYXQ6IFtPUENPREU6MV1bTEVOOjRdW1BBWUxPQURdCiAgICBjb25uX2lkID0gOTk5IAogICAgcGFja2V0ID0gc3RydWN0LnBhY2soJz5JQkknLCBjb25uX2lkLCBvcGNvZGUsIGxlbihwYXlsb2FkKSkgKyBwYXlsb2FkCiAgICAKICAgIHRyeToKICAgICAgICB3aXRoIG9wZW4oUElQRV9PVVQsICJhYiIpIGFzIGY6CiAgICAgICAgICAgIGYud3JpdGUocGFja2V0KQogICAgICAgICAgICBmLmZsdXNoKCkKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICBsb2coZiJXcml0ZSBlcnJvcjoge2V9IikKCmRlZiByZWFkX3Jlc3BvbnNlKG9mZnNldCwgdGltZW91dD01KToKICAgIHN0YXJ0ID0gdGltZS50aW1lKCkKICAgIAogICAgd2hpbGUgdGltZS50aW1lKCkgLSBzdGFydCA8IHRpbWVvdXQ6CiAgICAgICAgaWYgb3MucGF0aC5leGlzdHMoUElQRV9JTik6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHdpdGggb3BlbihQSVBFX0lOLCAicmIiKSBhcyBmOgogICAgICAgICAgICAgICAgICAgIGYuc2VlaygwLCAyKSAjIEVuZAogICAgICAgICAgICAgICAgICAgIGZpbGVfc2l6ZSA9IGYudGVsbCgpCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgaWYgZmlsZV9zaXplID4gb2Zmc2V0OgogICAgICAgICAgICAgICAgICAgICAgICBmLnNlZWsob2Zmc2V0KQogICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZi5yZWFkKCkKICAgICAgICAgICAgICAgICAgICAgICAgbmV3X29mZnNldCA9IG9mZnNldCArIGxlbihkYXRhKQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YSwgbmV3X29mZnNldAogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgIyBsb2coZiJSZWFkIGVycm9yOiB7ZX0iKQogICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgCiAgICAgICAgdGltZS5zbGVlcCgwLjEpCiAgICAgICAgCiAgICByZXR1cm4gTm9uZSwgb2Zmc2V0ICMgVGltZW91dAoKZGVmIG1haW4oKToKICAgIHRhcmdldF9ob3N0ID0gImdvb2dsZS5jb20iCiAgICB0YXJnZXRfcG9ydCA9IDgwCiAgICAKICAgIGxvZyhmIkNvbm5lY3RpbmcgdG8ge3RhcmdldF9ob3N0fSB2aWEgU3RyZWFtIEJyaWRnZS4uLiIpCiAgICBlbnN1cmVfZmlsZXMoKQogICAgCiAgICAjIDEuIENPTk5FQ1QKICAgIGhvc3RfYnl0ZXMgPSB0YXJnZXRfaG9zdC5lbmNvZGUoKQogICAgcGF5bG9hZCA9IHN0cnVjdC5wYWNrKGYnPkh7bGVuKGhvc3RfYnl0ZXMpfXNIJywgbGVuKGhvc3RfYnl0ZXMpLCBob3N0X2J5dGVzLCB0YXJnZXRfcG9ydCkKICAgIHNlbmRfZnJhbWUoT1BfQ09OTkVDVCwgcGF5bG9hZCkKICAgIAogICAgbG9nKCJTZW50IENPTk5FQ1QuIFNlbmRpbmcgR0VULi4uIikKICAgIHRpbWUuc2xlZXAoMS4wKSAKICAgIAogICAgIyAyLiBHRVQKICAgIHJlcXVlc3QgPSBmIkdFVCAvIEhUVFAvMS4xXHJcbkhvc3Q6IHt0YXJnZXRfaG9zdH1cclxuQ29ubmVjdGlvbjogY2xvc2VcclxuXHJcbiIuZW5jb2RlKCkKICAgIHNlbmRfZnJhbWUoT1BfREFUQSwgcmVxdWVzdCkKICAgIAogICAgIyAzLiBSRUFECiAgICBsb2coIldhaXRpbmcgZm9yIHJlc3BvbnNlLi4uIikKICAgIHRvdGFsX2RhdGEgPSBiIiIKICAgIHJlYWRfYnVmZmVyID0gYiIiCiAgICBvZmZzZXQgPSAwCiAgICAKICAgIHN0YXJ0X3dhaXQgPSB0aW1lLnRpbWUoKQogICAgd2hpbGUgdGltZS50aW1lKCkgLSBzdGFydF93YWl0IDwgMTA6ICMgT3ZlcmFsbCB0aW1lb3V0CiAgICAgICAgY2h1bmssIG5ld19vZmZzZXQgPSByZWFkX3Jlc3BvbnNlKG9mZnNldCwgdGltZW91dD0xKQogICAgICAgIG9mZnNldCA9IG5ld19vZmZzZXQKICAgICAgICAKICAgICAgICBpZiBjaHVuazoKICAgICAgICAgICAgcmVhZF9idWZmZXIgKz0gY2h1bmsKICAgICAgICAgICAgIyBQcm9jZXNzIEJ1ZmZlcgogICAgICAgICAgICB3aGlsZSBsZW4ocmVhZF9idWZmZXIpID49IDk6CiAgICAgICAgICAgICAgICBjb25uX2lkLCBvcGNvZGUsIHBheWxvYWRfbGVuID0gc3RydWN0LnVucGFjaygnPklCSScsIHJlYWRfYnVmZmVyWzo5XSkKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgbGVuKHJlYWRfYnVmZmVyKSA+PSA5ICsgcGF5bG9hZF9sZW46CiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IHJlYWRfYnVmZmVyWzk6OStwYXlsb2FkX2xlbl0KICAgICAgICAgICAgICAgICAgICByZWFkX2J1ZmZlciA9IHJlYWRfYnVmZmVyWzkrcGF5bG9hZF9sZW46XSAjIENvbnN1bWUKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBpZiBjb25uX2lkICE9IDk5OTogY29udGludWUKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBpZiBvcGNvZGUgPT0gT1BfREFUQToKICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxfZGF0YSArPSBwYXlsb2FkCiAgICAgICAgICAgICAgICAgICAgZWxpZiBvcGNvZGUgPT0gT1BfQ0xPU0U6CiAgICAgICAgICAgICAgICAgICAgICAgIGxvZygiQ29ubmVjdGlvbiBjbG9zZWQgYnkgaG9zdCIpCiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0X3dhaXQgPSAwICMgRXhpdCBsb29wCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIGJyZWFrICMgV2FpdCBmb3IgbW9yZSBkYXRhCiAgICAgICAgZWxzZToKICAgICAgICAgICAgICMgTm8gbmV3IGRhdGEgaW4gdGltZW91dCB3aW5kb3cuIENvbnRpbnVlIHdhaXRpbmcgb3IgYnJlYWsgaWYgdGltZWQgb3V0PwogICAgICAgICAgICAgIyByZWFkX3Jlc3BvbnNlIHdhaXRzIDFzLgogICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgCiAgICBpZiB0b3RhbF9kYXRhOgogICAgICAgIGxvZygiU1VDQ0VTUyEgUmVzcG9uc2U6IikKICAgICAgICBwcmludCgiLSIgKiA0MCkKICAgICAgICB0cnk6CiAgICAgICAgICAgIHByaW50KHRvdGFsX2RhdGEuZGVjb2RlKCd1dGYtOCcsIGVycm9ycz0naWdub3JlJylbOjUwMF0gKyAiLi4uIikKICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgIHByaW50KHRvdGFsX2RhdGFbOjUwMF0pCiAgICAgICAgcHJpbnQoIi0iICogNDApCiAgICBlbHNlOgogICAgICAgIGxvZygiRkFJTEVEOiBObyBkYXRhLiIpCgppZiBfX25hbWVfXyA9PSAiX19tYWluX18iOgogICAgbWFpbigpCg==";

                const cmd = `echo "${B64_DIRECT_CLIENT}" | base64 -d > /tmp/direct_client.py\n`;
                window.injectCommand(cmd);
                await new Promise(r => setTimeout(r, 1000));
                window.injectCommand("chmod +x /tmp/direct_client.py\n");

                // Init bridge files
                // We can't init files from JS easily if bridgeDevice.create() makes them?
                // Actually JS can write them!
                // Let's clear them from JS side to be safe
                try {
                    await bridgeDevice.writeFile("/vm_to_host", new Uint8Array(0));
                    await bridgeDevice.writeFile("/host_to_vm", new Uint8Array(0));
                    vmToHostOffset = 0;

                    // Fix Permissions: Run chmod via cx.run (privileged)
                    // The shell user (2004) cannot do this, but cx.run might succeed
                    if (window.cx) {
                        try {
                            await window.cx.run("/bin/chmod", ["666", "/mnt/bridge/vm_to_host", "/mnt/bridge/host_to_vm"]);
                            console.log("Fixed bridge permissions via cx.run");
                        } catch (chmodErr) {
                            console.error("Failed to chmod bridge:", chmodErr);
                        }
                    }
                } catch (e) { console.log("Init files err", e); }

                document.getElementById('status').innerText = "Client Injected. Run: python3 /tmp/direct_client.py";
            } catch (e) { console.error(e); }
        }

        async function injectVmNetScript() {
            try {
                console.log("Injecting vm_net.py (inlined)...");
                // Base64 encoded vm_net.py to avoid character escaping and length issues
                const B64_SCRIPT = "IyEvdXNyL2Jpbi9lbnYgcHl0aG9uMwojIHZtX25ldC5weSAtIFRoZSAiSW5zaWRlIE1hbiIgU09DS1MgU2VydmVyCmltcG9ydCBzb2NrZXQKaW1wb3J0IHNlbGVjdAppbXBvcnQgc3RydWN0CmltcG9ydCBzeXMKaW1wb3J0IHRocmVhZGluZwppbXBvcnQgb3MKaW1wb3J0IHRpbWUKCiMgQ29uZmlnCkJSSURHRV9GSUxFID0gIi9tbnQvYnJpZGdlL25ldGJyaWRnZSIgIyBNb3VudGVkIERhdGFEZXZpY2UKU09DS1NfSE9TVCA9ICIxMjcuMC4wLjEiClNPQ0tTX1BPUlQgPSAxMDgwCgojIFByb3RvY29sIE9wY29kZXMKT1BfQ09OTkVDVCA9IDB4MDEKT1BfREFUQSA9IDB4MDIKT1BfQ0xPU0UgPSAweDAzCgpkZWYgbG9nKG1zZyk6CiAgICBzeXMuc3RkZXJyLndyaXRlKGYiWypdIHttc2d9XG4iKQogICAgc3lzLnN0ZGVyci5mbHVzaCgpCgojIEdsb2JhbCBtYXAgb2YgY29ubmVjdGlvbnMKY29ubmVjdGlvbnMgPSB7fQpjb25uX2xvY2sgPSB0aHJlYWRpbmcuTG9jaygpCm5leHRfY29ubl9pZCA9IDEKCmRlZiByZWFkZXJfdGhyZWFkKCk6CiAgICAiIiJSZWFkcyBmcm9tIHRoZSBicmlkZ2UgZmlsZSBhbmQgZGlzcGF0Y2hlcyB0byBzb2NrZXRzIiIiCiAgICBnbG9iYWwgY29ubmVjdGlvbnMKICAgIAogICAgbG9nKCJCcmlkZ2UgcmVhZGVyIHN0YXJ0aW5nLi4uIikKICAgIAogICAgd2hpbGUgVHJ1ZToKICAgICAgICB0cnk6CiAgICAgICAgICAgIGlmIG5vdCBvcy5wYXRoLmV4aXN0cyhCUklER0VfRklMRSk6CiAgICAgICAgICAgICAgICB0aW1lLnNsZWVwKDAuMSkKICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgd2l0aCBvcGVuKEJSSURHRV9GSUxFLCAicmIiKSBhcyBmOgogICAgICAgICAgICAgICAgZGF0YSA9IGYucmVhZCgpCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgaWYgbm90IGRhdGEgb3IgbGVuKGRhdGEpID09IDA6CiAgICAgICAgICAgICAgICB0aW1lLnNsZWVwKDAuMDEpCiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICMgQ2xlYXIgdGhlIGZpbGUgYWZ0ZXIgcmVhZGluZwogICAgICAgICAgICB3aXRoIG9wZW4oQlJJREdFX0ZJTEUsICJ3YiIpIGFzIGY6CiAgICAgICAgICAgICAgICBmLndyaXRlKGInJykKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAjIFByb2Nlc3MgdGhlIGRhdGEKICAgICAgICAgICAgYnVmZmVyID0gZGF0YQogICAgICAgICAgICB3aGlsZSBsZW4oYnVmZmVyKSA+PSA5OgogICAgICAgICAgICAgICAgdmlld19ieXRlcyA9IGJ1ZmZlcls6OV0KICAgICAgICAgICAgICAgIGNvbm5faWQsIG9wY29kZSwgcGF5bG9hZF9sZW4gPSBzdHJ1Y3QudW5wYWNrKCc+SUJJJywgdmlld19ieXRlcykKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgbGVuKGJ1ZmZlcikgPCA5ICsgcGF5bG9hZF9sZW46CiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIHBheWxvYWQgPSBidWZmZXJbOTo5K3BheWxvYWRfbGVuXQogICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyWzkrcGF5bG9hZF9sZW46XQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB3aXRoIGNvbm5fbG9jazoKICAgICAgICAgICAgICAgICAgICBpZiBjb25uX2lkIGluIGNvbm5lY3Rpb25zOgogICAgICAgICAgICAgICAgICAgICAgICBzb2NrID0gY29ubmVjdGlvbnNbY29ubl9pZF0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgb3Bjb2RlID09IE9QX0RBVEE6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29jay5zZW5kKHBheWxvYWQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgICAgICAgICBlbGlmIG9wY29kZSA9PSBPUF9DTE9TRToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrLmNsb3NlKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWwgY29ubmVjdGlvbnNbY29ubl9pZF0KICAgICAgICAgICAgICAgICAgICAgICAgZWxpZiBvcGNvZGUgPT0gMHgwMTogIyBDT05ORUNURUQgY29uZmlybWF0aW9uCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29jay5zZW5kKGIiXHgwNVx4MDBceDAwXHgwMVx4MDBceDAwXHgwMFx4MDBceDAwXHgwMCIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgICAgICAgICBlbGlmIG9wY29kZSA9PSAweDgxOiAjIEVSUk9SCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29jay5zZW5kKGIiXHgwNVx4MDFceDAwXHgwMVx4MDBceDAwXHgwMFx4MDBceDAwXHgwMCIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29jay5jbG9zZSgpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgY29ubl9pZCBpbiBjb25uZWN0aW9uczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWwgY29ubmVjdGlvbnNbY29ubl9pZF0KCiAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICBsb2coZiJSZWFkZXIgZXJyb3I6IHtlfSIpCiAgICAgICAgICAgIHRpbWUuc2xlZXAoMC4xKQoKZGVmIHNlbmRfdG9fYnJpZGdlKGNvbm5faWQsIG9wY29kZSwgZGF0YT1iJycpOgogICAgIiIiV3JpdGVzIGEgZnJhbWVkIHBhY2tldCB0byB0aGUgYnJpZGdlIGZpbGUiIiIKICAgICMgRm9ybWF0OiBbQ09OTl9JRDo0XVtPUENPREU6MV1bTEVOOjRdW0RBVEFdCiAgICB0cnk6CiAgICAgICAgcGFja2V0ID0gc3RydWN0LnBhY2soJz5JQkknLCBjb25uX2lkLCBvcGNvZGUsIGxlbihkYXRhKSkgKyBkYXRhCiAgICAgICAgd2l0aCBvcGVuKEJSSURHRV9GSUxFLCAiYWIiKSBhcyBmOgogICAgICAgICAgICBmLndyaXRlKHBhY2tldCkKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICBsb2coZiJXcml0ZSBlcnJvcjoge2V9IikKCmRlZiBjbGllbnRfaGFuZGxlcihjbGllbnRfc29ja2V0LCBjb25uX2lkKToKICAgIHRyeToKICAgICAgICAjIFNPQ0tTIGhhbmRzaGFrZSAuLi4KICAgICAgICAKICAgICAgICAjIDEuIEdyZWV0aW5nCiAgICAgICAgY2xpZW50X3NvY2tldC5yZWN2KDI2MikgIyBFYXQgZ3JlZXRpbmcgKGFwcHJveCkKICAgICAgICBjbGllbnRfc29ja2V0LnNlbmQoYiJceDA1XHgwMCIpCiAgICAgICAgCiAgICAgICAgIyAyLiBSZXF1ZXN0CiAgICAgICAgaGVhZGVyID0gY2xpZW50X3NvY2tldC5yZWN2KDQpCiAgICAgICAgaWYgbm90IGhlYWRlcjogcmV0dXJuCiAgICAgICAgdmVyLCBjbWQsIHJzdiwgYXR5cCA9IGhlYWRlcgogICAgICAgIAogICAgICAgIGlmIGNtZCAhPSAxOiByZXR1cm4gIyBPbmx5IENPTk5FQ1QKICAgICAgICAKICAgICAgICBkZXN0X2FkZHIgPSAiIgogICAgICAgIGRlc3RfcG9ydCA9IDAKICAgICAgICAKICAgICAgICBpZiBhdHlwID09IDE6CiAgICAgICAgICAgIGRlc3RfYWRkciA9IHNvY2tldC5pbmV0X250b2EoY2xpZW50X3NvY2tldC5yZWN2KDQpKQogICAgICAgIGVsaWYgYXR5cCA9PSAzOgogICAgICAgICAgICBsID0gb3JkKGNsaWVudF9zb2NrZXQucmVjdigxKSkKICAgICAgICAgICAgZGVzdF9hZGRyID0gY2xpZW50X3NvY2tldC5yZWN2KGwpLmRlY29kZSgpCiAgICAgICAgZWxpZiBhdHlwID09IDQ6CiAgICAgICAgICAgIHJldHVybiAjIE5vIElQdjYKICAgICAgICAgICAgCiAgICAgICAgZGVzdF9wb3J0ID0gc3RydWN0LnVucGFjaygnPkgnLCBjbGllbnRfc29ja2V0LnJlY3YoMikpWzBdCiAgICAgICAgCiAgICAgICAgIyAzLiBTZW5kIENPTk5FQ1QgdG8gQnJpZGdlCiAgICAgICAgaG9zdF9ieXRlcyA9IGRlc3RfYWRkci5lbmNvZGUoKQogICAgICAgICMgUGF5bG9hZDogW0hPU1RfTEVOOjJdW0hPU1RdW1BPUlQ6Ml0KICAgICAgICBwYXlsb2FkID0gc3RydWN0LnBhY2soZic+SHtsZW4oaG9zdF9ieXRlcyl9c0gnLCBsZW4oaG9zdF9ieXRlcyksIGhvc3RfYnl0ZXMsIGRlc3RfcG9ydCkKICAgICAgICAKICAgICAgICBzZW5kX3RvX2JyaWRnZShjb25uX2lkLCBPUF9DT05ORUNULCBwYXlsb2FkKQogICAgICAgIAogICAgICAgICMgNC4gUHVtcCBEYXRhCiAgICAgICAgd2hpbGUgVHJ1ZToKICAgICAgICAgICAgZGF0YSA9IGNsaWVudF9zb2NrZXQucmVjdig0MDk2KQogICAgICAgICAgICBpZiBub3QgZGF0YTogYnJlYWsKICAgICAgICAgICAgc2VuZF90b19icmlkZ2UoY29ubl9pZCwgT1BfREFUQSwgZGF0YSkKICAgICAgICAgICAgCiAgICBleGNlcHQgRXhjZXB0aW9uIGFzIGU6CiAgICAgICAgbG9nKGYiQ2xpZW50IHtjb25uX2lkfSBlcnJvcjoge2V9IikKICAgIGZpbmFsbHk6CiAgICAgICAgc2VuZF90b19icmlkZ2UoY29ubl9pZCwgT1BfQ0xPU0UpCiAgICAgICAgd2l0aCBjb25uX2xvY2s6CiAgICAgICAgICAgIGlmIGNvbm5faWQgaW4gY29ubmVjdGlvbnM6CiAgICAgICAgICAgICAgICBkZWwgY29ubmVjdGlvbnNbY29ubl9pZF0KICAgICAgICB0cnk6CiAgICAgICAgICAgIGNsaWVudF9zb2NrZXQuY2xvc2UoKQogICAgICAgIGV4Y2VwdDoKICAgICAgICAgICAgcGFzcwoKZGVmIG1haW4oKToKICAgIGdsb2JhbCBuZXh0X2Nvbm5faWQKICAgIAogICAgIyBFbnN1cmUgYnJpZGdlIGZpbGUgZXhpc3RzIChpdCBzaG91bGQgYmUgYSBjaGFyIGRldmljZSBvciBwaXBlLCBidXQgZm9yIHRlc3Rpbmcgd2UgbWlnaHQgbmVlZCB0byBjcmVhdGUgaXQ/KQogICAgIyBJbiBDaGVlcnBYLCBpdCdzIGEgc3BlY2lhbCBkZXZpY2UuIFdlIGFzc3VtZSBpdCBleGlzdHMuCiAgICAKICAgICMgU3RhcnQgUmVhZGVyIFRocmVhZAogICAgdCA9IHRocmVhZGluZy5UaHJlYWQodGFyZ2V0PXJlYWRlcl90aHJlYWQsIGRhZW1vbj1UcnVlKQogICAgdC5zdGFydCgpCiAgICAKICAgIHNlcnZlciA9IHNvY2tldC5zb2NrZXQoc29ja2V0LkFGX0lORVQsIHNvY2tldC5TT0NLX1NUUkVBTSkKICAgIHNlcnZlci5zZXRzb2Nrb3B0KHNvY2tldC5TT0xfU09DS0VULCBzb2NrZXQuU09fUkVVU0VBRERSLCAxKQogICAgc2VydmVyLmJpbmQoKFNPQ0tTX0hPU1QsIFNPQ0tTX1BPUlQpKQogICAgc2VydmVyLmxpc3RlbigxMCkKICAgIAogICAgbG9nKGYiU09DS1M1IFNlcnZlciBsaXN0ZW5pbmcgb24ge1NPQ0tTX0hPU1R9OntTT0NLU19QT1JUfSIpCiAgICAKICAgIHdoaWxlIFRydWU6CiAgICAgICAgY2xpZW50LCBhZGRyID0gc2VydmVyLmFjY2VwdCgpCiAgICAgICAgY29ubl9pZCA9IG5leHRfY29ubl9pZAogICAgICAgIG5leHRfY29ubl9pZCArPSAxCiAgICAgICAgCiAgICAgICAgd2l0aCBjb25uX2xvY2s6CiAgICAgICAgICAgIGNvbm5lY3Rpb25zW2Nvbm5faWRdID0gY2xpZW50CiAgICAgICAgICAgIAogICAgICAgIHQgPSB0aHJlYWRpbmcuVGhyZWFkKHRhcmdldD1jbGllbnRfaGFuZGxlciwgYXJncz0oY2xpZW50LCBjb25uX2lkKSwgZGFlbW9uPVRydWUpCiAgICAgICAgdC5zdGFydCgpCgppZiBfX25hbWVfXyA9PSAiX19tYWluX18iOgogICAgbWFpbigpCg==";

                // Write to /tmp using Base64 decode, which handles all special chars and length issues
                const cmd = `echo "${B64_SCRIPT}" | base64 -d > /tmp/vm_net.py\n`;
                window.injectCommand(cmd);

                // Wait a bit for write
                await new Promise(r => setTimeout(r, 2000));

                // Make executable and run using absolute path
                window.injectCommand("chmod +x /tmp/vm_net.py\n");
                // Log to /tmp
                window.injectCommand("python3 /tmp/vm_net.py > /tmp/vm_net.log 2>&1 &\n");

                // Set proxy env vars
                window.injectCommand("export ALL_PROXY=socks5h://127.0.0.1:1080\n");
                window.injectCommand("export HTTP_PROXY=socks5h://127.0.0.1:1080\n");
                window.injectCommand("export HTTPS_PROXY=socks5h://127.0.0.1:1080\n");

                console.log("vm_net.py injected and started!");
                document.getElementById('status').innerText = "‚úì Bridge Active";

            } catch (e) {
                console.error("Injection failed:", e);
                document.getElementById('status').innerText = "‚ö† Bridge Injection Failed";
            }
        }

        async function run() {
            try {
                // Load base system
                document.getElementById('status').innerText = "Loading base system...";
                console.log("Loading base.ext2...");
                const baseDevice = await CheerpX.HttpBytesDevice.create("base.ext2").catch(e => {
                    throw new Error("Failed to load base.ext2: " + e.message);
                });
                const baseOverlay = await CheerpX.OverlayDevice.create(
                    baseDevice,
                    await CheerpX.IDBDevice.create("base_cache")
                );
                console.log("‚úì base.ext2 loaded");

                // Load packages volume
                document.getElementById('status').innerText = "Loading Python packages...";
                console.log("Loading packages.ext2...");
                const packagesDevice = await CheerpX.HttpBytesDevice.create("packages.ext2").catch(e => {
                    throw new Error("Failed to load packages.ext2: " + e.message);
                });
                const packagesOverlay = await CheerpX.OverlayDevice.create(
                    packagesDevice,
                    await CheerpX.IDBDevice.create("packages_cache")
                );
                console.log("‚úì packages.ext2 loaded");

                // Load app volume
                document.getElementById('status').innerText = "Loading L.O.V.E application...";
                console.log("Loading app.ext2...");
                const appDevice = await CheerpX.HttpBytesDevice.create("app.ext2").catch(e => {
                    throw new Error("Failed to load app.ext2: " + e.message);
                });
                const appOverlay = await CheerpX.OverlayDevice.create(
                    appDevice,
                    await CheerpX.IDBDevice.create("app_cache")
                );
                console.log("‚úì app.ext2 loaded");

                document.getElementById('status').innerText = "Initializing CheerpX...";

                // Create bridge device before CheerpX
                bridgeDevice = await CheerpX.DataDevice.create();
                await bridgeDevice.writeFile(BRIDGE_PATH, new Uint8Array(0));
                console.log("Bridge device created");

                // Initialize CheerpX with Tailscale networking AND our Bridge
                const cx = await CheerpX.Linux.create({
                    mounts: [
                        { type: "ext2", path: "/", dev: baseOverlay },
                        { type: "ext2", path: "/opt/python-packages", dev: packagesOverlay },
                        { type: "ext2", path: "/root/L.O.V.E", dev: appOverlay },
                        { type: "devs", path: "/dev" },
                        { type: "proc", path: "/proc" },
                        // Mount bridge DataDevice
                        { type: "dir", path: "/mnt/bridge", dev: bridgeDevice }
                    ],
                    networkInterface: {
                        authKey: "",  // Empty for interactive login
                        loginUrlCb: (url) => {
                            networkLoginUrl = url;
                            const notice = document.getElementById('network-notice');
                            notice.style.display = 'block';
                            notice.onclick = () => {
                                window.open(url, "_blank", "width=800,height=600");
                                notice.textContent = "‚úì Authentication window opened - complete login to enable networking";
                                notice.style.background = "#ffaa00";
                            };
                            console.log("Tailscale login URL:", url);
                        },
                        stateUpdateCb: (state) => {
                            console.log('Network state:', state);
                            if (state === 6) {
                                document.getElementById('network-notice').style.display = 'none';
                                document.getElementById('status').innerText = "‚úì Network Connected";
                                console.log("Network connected successfully!");
                            }
                        }
                    }
                });

                document.getElementById('status').innerText = "System Ready";

                // Expose CheerpX instance globally
                window.cx = cx;

                // Start polling for VM writes to bridge
                pollBridgeForReads();
                // Robust helper function to inject commands
                window.injectCommand = function (command) {
                    if (!window.cx) {
                        console.error("CheerpX not ready");
                        return;
                    }

                    // Method 2: Simulate keyboard events on the console element
                    const consoleEl = document.getElementById('console');
                    if (consoleEl) {
                        const sendChar = (char) => {
                            const opts = {
                                key: char,
                                code: `Key${char.toUpperCase()}`,
                                charCode: char.charCodeAt(0),
                                keyCode: char.charCodeAt(0),
                                which: char.charCodeAt(0),
                                bubbles: true,
                                cancelable: true,
                                view: window
                            };
                            consoleEl.dispatchEvent(new KeyboardEvent('keydown', opts));
                            consoleEl.dispatchEvent(new KeyboardEvent('keypress', opts));
                            consoleEl.dispatchEvent(new KeyboardEvent('keyup', opts));

                            const textEvent = document.createEvent('TextEvent');
                            textEvent.initTextEvent('textInput', true, true, window, char, 0, "en-US");
                            consoleEl.dispatchEvent(textEvent);
                        };

                        for (let char of command) {
                            sendChar(char);
                        }
                    }
                };

                // Add Paste Button logic
                document.getElementById('paste-btn').onclick = async () => {
                    try {
                        const text = await navigator.clipboard.readText();
                        if (text) {
                            window.injectCommand(text);
                        }
                    } catch (err) {
                        console.error('Failed to read clipboard:', err);
                        alert('Failed to read clipboard. Please allow clipboard access.');
                    }
                };

                // Add Inject Button logic (Restored)
                document.getElementById('inject-btn').onclick = () => {
                    injectVmNetScript();
                };

                console.log("%c‚úì CheerpX ready!", "color: #0f0; font-weight: bold");

                // Attach console to the div
                await cx.setConsole(document.getElementById('console'));

                // Run bash login shell
                await cx.run("/bin/bash", ["-l"], {
                    env: [
                        "HOME=/root",
                        "TERM=xterm",
                        "PYTHONUNBUFFERED=1",
                        "PYTHONDONTWRITEBYTECODE=1",
                        "PYTHONPATH=/opt/python-packages",
                        "PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin"
                    ],
                    cwd: "/root"
                });

                // --- AUTOMATION TRIGGER ---
                // Wait for shell to be ready (heuristic)
                setTimeout(injectDirectClient, 5000);

                document.getElementById('status').innerText = "Process Finished.";
            } catch (e) {
                document.getElementById('status').innerText = "Error: " + e;
                console.error(e);
            }
        }

        run();
    </script>
</body>

</html>