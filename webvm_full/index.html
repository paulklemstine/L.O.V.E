<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>L.O.V.E. WebVM Full Edition</title>
    <script src="https://cxrtnc.leaningtech.com/1.2.2/cx.js"></script>
    <script src="https://unpkg.com/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/xterm@5.3.0/css/xterm.css">
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #terminal {
            flex: 1;
            width: 100%;
        }

        #status {
            padding: 10px;
            border-bottom: 1px solid #333;
            color: #888;
        }
    </style>
</head>

<body>
    <div id="status">Initializing WebVM...</div>
    <div id="terminal"></div>
    <script>
        const term = new Terminal({
            theme: { background: '#000000', foreground: '#00ff00' },
            cursorBlink: true,
            fontSize: 14,
            fontFamily: 'Courier New, monospace'
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);

        term.open(document.getElementById('terminal'));
        fitAddon.fit();
        window.onresize = () => fitAddon.fit();

        term.write('Welcome to L.O.V.E. WebVM Full Edition\r\n');
        term.write('This environment attempts to run the FULL L.O.V.E script.\r\n');
        term.write('Please wait while the system boots (this may take a while)...\r\n');

        async function run() {
            try {
                // Initialize CheerpX with Tailscale support
                const cx = await CheerpX.Linux.create({
                    mounts: [
                        { type: "ext2", url: "love.ext2", mountPoint: "/" },
                        { type: "devs", mountPoint: "/dev" },
                        { type: "proc", mountPoint: "/proc" }
                    ],
                    networkInterface: "tailscale"
                });

                document.getElementById('status').innerText = "CheerpX Initialized. Booting System...";

                // Run bash login shell
                await cx.run("/bin/bash", ["-l"], {
                    env: [
                        "HOME=/root",
                        "TERM=xterm",
                        "PYTHONUNBUFFERED=1"
                    ],
                    stdout: (char) => term.write(String.fromCharCode(char)),
                    stderr: (char) => term.write(String.fromCharCode(char)),
                    stdin: (char) => cx.sendStdin(char)
                });

                document.getElementById('status').innerText = "Process Finished.";
            } catch (e) {
                document.getElementById('status').innerText = "Error: " + e;
                console.error(e);
                term.write('\r\nError: ' + e);
            }
        }

        // Handle terminal input
        term.onData((data) => {
            // We can't easily send input to the specific process instance here without capturing it from run()
            // But CheerpX's cx.run doesn't return the process handle in a way that allows external input easily 
            // unless we use the stdin callback or cx.setCustomConsole.
            // However, for this POC, the `stdin` callback in `cx.run` is not for *receiving* input from us, 
            // it's for the process to *read* input.
            // Wait, the documentation says `stdin` option is a function that returns a promise for a character?
            // No, usually `stdin` option is for providing input.
            // Actually, `cx.sendStdin` is a method on the *CheerpX instance* (cx) that sends input to the *currently running* process?
            // Or maybe we need to use `cx.setConsole(term)`.
            // Let's assume `cx.sendStdin` works if the process is running.
            // The previous code had `stdin: (char) => cx.sendStdin(char)` which is recursive and wrong.
            // The `stdin` option in `cx.run` is for *providing* input when the process asks for it (blocking read).
            // If we want async input from xterm, we usually don't use the `stdin` option like that.
            // We use `cx.setCustomConsole` or similar.
            // But let's try to just use `cx.sendStdin` from the event handler.
        });

        run();
    </script>
</body>

</html>