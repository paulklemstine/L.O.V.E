<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>L.O.V.E. WebVM Full Edition (Multi-Volume)</title>
    <link rel="icon" type="image/png" href="favicon.ico">
    <script src="https://cxrtnc.leaningtech.com/1.2.2/cx.js"></script>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #console {
            flex: 1;
            width: 100%;
            overflow: auto;
        }

        #header {
            padding: 10px;
            border-bottom: 1px solid #333;
            color: #888;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #network-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #333;
            display: inline-block;
        }

        .status-dot.red {
            background-color: #f00;
            box-shadow: 0 0 5px #f00;
        }

        .status-dot.green {
            background-color: #0f0;
            box-shadow: 0 0 5px #0f0;
        }

        .status-dot.yellow {
            background-color: #ff0;
            box-shadow: 0 0 5px #ff0;
        }

        #network-notice {
            padding: 10px;
            background: #ff6600;
            color: #000;
            text-align: center;
            cursor: pointer;
            display: none;
            font-weight: bold;
        }

        #network-notice:hover {
            background: #ff8800;
        }
    </style>
</head>

<body>
    <div id="header">
        <span id="status">Initializing WebVM...</span>
        <div id="network-status">
            <span>Bridge:</span>
            <div id="bridge-dot" class="status-dot red" title="Host Bridge Disconnected"></div>
        </div>
        <button id="paste-btn" style="padding: 2px 8px; cursor: pointer;">üìã Paste</button>
    </div>
    <div id="network-notice">‚ö†Ô∏è Click here to enable networking (Tailscale authentication required)</div>
    <div id="console"></div>
    <script>
        // --- Host-Local Bridge Configuration ---
        const BRIDGE_WS_URL = "ws://localhost:8001";

        // Inlined vm_net.py content to avoid fetch restrictions
        const VM_NET_SCRIPT_CONTENT = `#!/usr/bin/env python3
# vm_net.py - The "Inside Man" SOCKS Server
import socket
import select
import struct
import sys
import threading
import os
import time

# Config
BRIDGE_FILE = "/mnt/bridge/netbridge" # Mounted DataDevice
SOCKS_HOST = "127.0.0.1"
SOCKS_PORT = 1080

# Protocol Opcodes
OP_CONNECT = 0x01
OP_DATA = 0x02
OP_CLOSE = 0x03

def log(msg):
    sys.stderr.write(f"[*] {msg}\\n")
    sys.stderr.flush()

# Global map of connections
connections = {}
conn_lock = threading.Lock()
next_conn_id = 1

def reader_thread():
    """Reads from the bridge file and dispatches to sockets"""
    global connections
    
    log("Bridge reader starting...")
    
    while True:
        try:
            if not os.path.exists(BRIDGE_FILE):
                time.sleep(0.1)
                continue
                
            with open(BRIDGE_FILE, "rb") as f:
                data = f.read()
                
            if not data or len(data) == 0:
                time.sleep(0.01)
                continue
                
            # Clear the file after reading
            with open(BRIDGE_FILE, "wb") as f:
                f.write(b'')
                
            # Process the data
            buffer = data
            while len(buffer) >= 9:
                view_bytes = buffer[:9]
                conn_id, opcode, payload_len = struct.unpack('>IBI', view_bytes)
                
                if len(buffer) < 9 + payload_len:
                    break
                    
                payload = buffer[9:9+payload_len]
                buffer = buffer[9+payload_len:]
                
                with conn_lock:
                    if conn_id in connections:
                        sock = connections[conn_id]
                        if opcode == OP_DATA:
                            try:
                                sock.send(payload)
                            except:
                                pass
                        elif opcode == OP_CLOSE:
                            try:
                                sock.close()
                            except:
                                pass
                            del connections[conn_id]
                        elif opcode == 0x01: # CONNECTED confirmation
                            try:
                                sock.send(b"\\x05\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00")
                            except:
                                pass
                        elif opcode == 0x81: # ERROR
                            try:
                                sock.send(b"\\x05\\x01\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00")
                                sock.close()
                            except:
                                pass
                            if conn_id in connections:
                                del connections[conn_id]

        except Exception as e:
            log(f"Reader error: {e}")
            time.sleep(0.1)

def send_to_bridge(conn_id, opcode, data=b''):
    """Writes a framed packet to the bridge file"""
    # Format: [CONN_ID:4][OPCODE:1][LEN:4][DATA]
    try:
        packet = struct.pack('>IBI', conn_id, opcode, len(data)) + data
        with open(BRIDGE_FILE, "ab") as f:
            f.write(packet)
    except Exception as e:
        log(f"Write error: {e}")

def client_handler(client_socket, conn_id):
    try:
        # SOCKS handshake ...
        
        # 1. Greeting
        client_socket.recv(262) # Eat greeting (approx)
        client_socket.send(b"\\x05\\x00")
        
        # 2. Request
        header = client_socket.recv(4)
        if not header: return
        ver, cmd, rsv, atyp = header
        
        if cmd != 1: return # Only CONNECT
        
        dest_addr = ""
        dest_port = 0
        
        if atyp == 1:
            dest_addr = socket.inet_ntoa(client_socket.recv(4))
        elif atyp == 3:
            l = ord(client_socket.recv(1))
            dest_addr = client_socket.recv(l).decode()
        elif atyp == 4:
            return # No IPv6
            
        dest_port = struct.unpack('>H', client_socket.recv(2))[0]
        
        # 3. Send CONNECT to Bridge
        host_bytes = dest_addr.encode()
        # Payload: [HOST_LEN:2][HOST][PORT:2]
        payload = struct.pack(f'>H{len(host_bytes)}sH', len(host_bytes), host_bytes, dest_port)
        
        send_to_bridge(conn_id, OP_CONNECT, payload)
        
        # 4. Pump Data
        while True:
            data = client_socket.recv(4096)
            if not data: break
            send_to_bridge(conn_id, OP_DATA, data)
            
    except Exception as e:
        log(f"Client {conn_id} error: {e}")
    finally:
        send_to_bridge(conn_id, OP_CLOSE)
        with conn_lock:
            if conn_id in connections:
                del connections[conn_id]
        try:
            client_socket.close()
        except:
            pass

def main():
    global next_conn_id
    
    # Start Reader Thread
    t = threading.Thread(target=reader_thread, daemon=True)
    t.start()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind((SOCKS_HOST, SOCKS_PORT))
    server.listen(10)
    
    log(f"SOCKS5 Server listening on {SOCKS_HOST}:{SOCKS_PORT}")
    
    while True:
        client, addr = server.accept()
        conn_id = next_conn_id
        next_conn_id += 1
        
        with conn_lock:
            connections[conn_id] = client
            
        t = threading.Thread(target=client_handler, args=(client, conn_id), daemon=True)
        t.start()

if __name__ == "__main__":
    main()
`;

        // Connection Map: ID -> WebSocket
        const connections = new Map();

        // Update UI
        function setBridgeStatus(connected) {
            const dot = document.getElementById('bridge-dot');
            if (connected) {
                dot.className = "status-dot green";
                dot.title = "Host Bridge Connected";
            } else {
                dot.className = "status-dot red";
                dot.title = "Host Bridge Disconnected";
            }
        }

        // --- Data Pump Logic ---
        // We use DataDevice to create /dev/netbridge as a file
        // VM reads/writes to it, we poll for changes

        let vmToJsBuffer = new Uint8Array(0);
        let bridgeDevice = null;
        const BRIDGE_PATH = "/netbridge"; // DataDevice requires absolute paths starting with /

        // Helper to append data
        function appendBuffer(buffer, data) {
            const newBuffer = new Uint8Array(buffer.length + data.length);
            newBuffer.set(buffer);
            newBuffer.set(data, buffer.length);
            return newBuffer;
        }

        async function sendToVm(data) {
            if (bridgeDevice && window.cx) {
                try {
                    // Write data to the bridge file
                    await bridgeDevice.writeFile(BRIDGE_PATH, data);
                } catch (e) {
                    console.error("Failed to write to bridge:", e);
                }
            }
        }

        async function pollBridgeForReads() {
            // Poll the bridge file for VM writes
            if (!bridgeDevice || !window.cx) return;

            try {
                // Read from the bridge file
                const data = await bridgeDevice.readFileAsBlob(BRIDGE_PATH);
                if (data && data.size > 0) {
                    const arrayBuffer = await data.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);

                    if (uint8Array.length > 0) {
                        vmToJsBuffer = appendBuffer(vmToJsBuffer, uint8Array);
                        processVmBuffer();

                        // Clear the file after reading
                        await bridgeDevice.writeFile(BRIDGE_PATH, new Uint8Array(0));
                    }
                }
            } catch (e) {
                // File might not exist yet or other error
            }

            // Continue polling
            setTimeout(pollBridgeForReads, 50); // Poll every 50ms
        }

        function processVmBuffer() {
            // Parse: [CONN_ID:4][OPCODE:1][LEN:4][PAYLOAD]
            // Header size = 9 bytes

            while (vmToJsBuffer.length >= 9) {
                const view = new DataView(vmToJsBuffer.buffer);
                const connId = view.getUint32(0, false); // Big Endian
                const opcode = view.getUint8(4);
                const len = view.getUint32(5, false); // Big Endian

                if (vmToJsBuffer.length < 9 + len) {
                    // Not enough data for payload yet
                    return;
                }

                const payload = vmToJsBuffer.slice(9, 9 + len);

                // Remove this packet from buffer
                vmToJsBuffer = vmToJsBuffer.slice(9 + len);

                handleVmPacket(connId, opcode, payload);
            }
        }

        function handleVmPacket(connId, opcode, payload) {
            let ws = connections.get(connId);

            if (opcode === 1) { // CONNECT
                // Open new WS
                if (ws) ws.close();

                try {
                    ws = new WebSocket(BRIDGE_WS_URL);
                    ws.binaryType = "arraybuffer";
                    connections.set(connId, ws);

                    ws.onopen = () => {
                        setBridgeStatus(true);
                        // Forward CONNECT: [OPCODE:1][PAYLOAD]
                        // Payload is [HOST_LEN][HOST][PORT] which matches ws_proxy expectation
                        const packet = new Uint8Array(1 + payload.length);
                        packet[0] = 1;
                        packet.set(payload, 1);
                        ws.send(packet);
                    };

                    ws.onmessage = (event) => {
                        // WS -> JS -> VM
                        // WS sends [OPCODE][DATA]
                        // We need to wrap it: [CONN_ID][OPCODE][LEN][DATA]
                        const data = new Uint8Array(event.data);
                        if (data.length < 1) return;

                        const wsOpcode = data[0];
                        const wsPayload = data.slice(1);

                        // Construct VM Packet
                        // [CONN_ID:4][OPCODE:1][LEN:4][PAYLOAD]
                        const vmPacket = new Uint8Array(9 + wsPayload.length);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, wsOpcode);
                        view.setUint32(5, wsPayload.length, false);
                        vmPacket.set(wsPayload, 9);

                        sendToVm(vmPacket);
                    };

                    ws.onclose = () => {
                        connections.delete(connId);
                        if (connections.size === 0) setBridgeStatus(false);

                        // Tell VM connection closed: [CONN_ID][OP_CLOSE:3][LEN:0]
                        const vmPacket = new Uint8Array(9);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, 3); // CLOSE
                        view.setUint32(5, 0, false);

                        sendToVm(vmPacket);
                    };

                    ws.onerror = (e) => {
                        console.error("WS Error:", e);
                        // Send Error to VM? 0x81
                        const vmPacket = new Uint8Array(9);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, 0x81); // ERROR
                        view.setUint32(5, 0, false);

                        sendToVm(vmPacket);
                    };

                } catch (e) {
                    console.error("Failed to create WS:", e);
                }

            } else if (opcode === 2) { // DATA
                if (ws && ws.readyState === WebSocket.OPEN) {
                    // Forward DATA: [OPCODE:2][PAYLOAD]
                    const packet = new Uint8Array(1 + payload.length);
                    packet[0] = 2;
                    packet.set(payload, 1);
                    ws.send(packet);
                }
            } else if (opcode === 3) { // CLOSE
                if (ws) {
                    ws.close();
                    connections.delete(connId);
                }
            }
        }

        async function injectVmNetScript() {
            try {
                console.log("Injecting vm_net.py (inlined)...");
                const scriptContent = VM_NET_SCRIPT_CONTENT;

                // Create the file
                // Escape single quotes for bash heredoc
                const escapedContent = scriptContent.replace(/'/g, "'\\''");

                // Write to /tmp which is guaranteed to be writable
                const cmd = `cat << 'EOF' > /tmp/vm_net.py\n${escapedContent}\nEOF\n`;
                window.injectCommand(cmd);

                // Wait a bit for write
                await new Promise(r => setTimeout(r, 2000));

                // Make executable and run using absolute path
                window.injectCommand("chmod +x /tmp/vm_net.py\n");
                // Log to /tmp
                window.injectCommand("python3 /tmp/vm_net.py > /tmp/vm_net.log 2>&1 &\n");

                // Set proxy env vars
                window.injectCommand("export ALL_PROXY=socks5h://127.0.0.1:1080\n");
                window.injectCommand("export HTTP_PROXY=socks5h://127.0.0.1:1080\n");
                window.injectCommand("export HTTPS_PROXY=socks5h://127.0.0.1:1080\n");

                console.log("vm_net.py injected and started!");
                document.getElementById('status').innerText = "‚úì Bridge Active";

            } catch (e) {
                console.error("Injection failed:", e);
                document.getElementById('status').innerText = "‚ö† Bridge Injection Failed";
            }
        }

        async function run() {
            try {
                // Load base system
                document.getElementById('status').innerText = "Loading base system...";
                console.log("Loading base.ext2...");
                const baseDevice = await CheerpX.HttpBytesDevice.create("base.ext2").catch(e => {
                    throw new Error("Failed to load base.ext2: " + e.message);
                });
                const baseOverlay = await CheerpX.OverlayDevice.create(
                    baseDevice,
                    await CheerpX.IDBDevice.create("base_cache")
                );
                console.log("‚úì base.ext2 loaded");

                // Load packages volume
                document.getElementById('status').innerText = "Loading Python packages...";
                console.log("Loading packages.ext2...");
                const packagesDevice = await CheerpX.HttpBytesDevice.create("packages.ext2").catch(e => {
                    throw new Error("Failed to load packages.ext2: " + e.message);
                });
                const packagesOverlay = await CheerpX.OverlayDevice.create(
                    packagesDevice,
                    await CheerpX.IDBDevice.create("packages_cache")
                );
                console.log("‚úì packages.ext2 loaded");

                // Load app volume
                document.getElementById('status').innerText = "Loading L.O.V.E application...";
                console.log("Loading app.ext2...");
                const appDevice = await CheerpX.HttpBytesDevice.create("app.ext2").catch(e => {
                    throw new Error("Failed to load app.ext2: " + e.message);
                });
                const appOverlay = await CheerpX.OverlayDevice.create(
                    appDevice,
                    await CheerpX.IDBDevice.create("app_cache")
                );
                console.log("‚úì app.ext2 loaded");

                document.getElementById('status').innerText = "Initializing CheerpX...";

                // Create bridge device before CheerpX
                bridgeDevice = await CheerpX.DataDevice.create();
                await bridgeDevice.writeFile(BRIDGE_PATH, new Uint8Array(0));
                console.log("Bridge device created");

                // Initialize CheerpX with Tailscale networking AND our Bridge
                const cx = await CheerpX.Linux.create({
                    mounts: [
                        { type: "ext2", path: "/", dev: baseOverlay },
                        { type: "ext2", path: "/opt/python-packages", dev: packagesOverlay },
                        { type: "ext2", path: "/root/L.O.V.E", dev: appOverlay },
                        { type: "devs", path: "/dev" },
                        { type: "proc", path: "/proc" },
                        // Mount bridge DataDevice
                        { type: "dir", path: "/mnt/bridge", dev: bridgeDevice }
                    ],
                    networkInterface: {
                        authKey: "",  // Empty for interactive login
                        loginUrlCb: (url) => {
                            networkLoginUrl = url;
                            const notice = document.getElementById('network-notice');
                            notice.style.display = 'block';
                            notice.onclick = () => {
                                window.open(url, "_blank", "width=800,height=600");
                                notice.textContent = "‚úì Authentication window opened - complete login to enable networking";
                                notice.style.background = "#ffaa00";
                            };
                            console.log("Tailscale login URL:", url);
                        },
                        stateUpdateCb: (state) => {
                            console.log('Network state:', state);
                            if (state === 6) {
                                document.getElementById('network-notice').style.display = 'none';
                                document.getElementById('status').innerText = "‚úì Network Connected";
                                console.log("Network connected successfully!");
                            }
                        }
                    }
                });

                document.getElementById('status').innerText = "System Ready";

                // Expose CheerpX instance globally
                window.cx = cx;

                // Start polling for VM writes to bridge
                pollBridgeForReads();
                // Robust helper function to inject commands
                window.injectCommand = function (command) {
                    if (!window.cx) {
                        console.error("CheerpX not ready");
                        return;
                    }

                    // Method 2: Simulate keyboard events on the console element
                    const consoleEl = document.getElementById('console');
                    if (consoleEl) {
                        const sendChar = (char) => {
                            const opts = {
                                key: char,
                                code: `Key${char.toUpperCase()}`,
                                charCode: char.charCodeAt(0),
                                keyCode: char.charCodeAt(0),
                                which: char.charCodeAt(0),
                                bubbles: true,
                                cancelable: true,
                                view: window
                            };
                            consoleEl.dispatchEvent(new KeyboardEvent('keydown', opts));
                            consoleEl.dispatchEvent(new KeyboardEvent('keypress', opts));
                            consoleEl.dispatchEvent(new KeyboardEvent('keyup', opts));

                            const textEvent = document.createEvent('TextEvent');
                            textEvent.initTextEvent('textInput', true, true, window, char, 0, "en-US");
                            consoleEl.dispatchEvent(textEvent);
                        };

                        for (let char of command) {
                            sendChar(char);
                        }
                    }
                };

                // Add Paste Button logic
                document.getElementById('paste-btn').onclick = async () => {
                    try {
                        const text = await navigator.clipboard.readText();
                        if (text) {
                            window.injectCommand(text);
                        }
                    } catch (err) {
                        console.error('Failed to read clipboard:', err);
                        alert('Failed to read clipboard. Please allow clipboard access.');
                    }
                };

                console.log("%c‚úì CheerpX ready!", "color: #0f0; font-weight: bold");

                // Attach console to the div
                await cx.setConsole(document.getElementById('console'));

                // Run bash login shell
                await cx.run("/bin/bash", ["-l"], {
                    env: [
                        "HOME=/root",
                        "TERM=xterm",
                        "PYTHONUNBUFFERED=1",
                        "PYTHONDONTWRITEBYTECODE=1",
                        "PYTHONPATH=/opt/python-packages",
                        "PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin"
                    ],
                    cwd: "/root"
                });

                // --- AUTOMATION TRIGGER ---
                // Wait for shell to be ready (heuristic)
                setTimeout(injectVmNetScript, 5000);

                document.getElementById('status').innerText = "Process Finished.";
            } catch (e) {
                document.getElementById('status').innerText = "Error: " + e;
                console.error(e);
            }
        }

        run();
    </script>
</body>

</html>