<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>L.O.V.E. WebVM Full Edition (Multi-Volume)</title>
    <link rel="icon" type="image/png" href="favicon.ico">
    <script src="https://cxrtnc.leaningtech.com/1.2.2/cx.js"></script>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #console {
            flex: 1;
            width: 100%;
            overflow: auto;
            white-space: pre-wrap;
            /* Ensure wrapping */
        }

        #header {
            padding: 10px;
            border-bottom: 1px solid #333;
            color: #888;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #network-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #333;
            display: inline-block;
        }

        .status-dot.red {
            background-color: #f00;
            box-shadow: 0 0 5px #f00;
        }

        .status-dot.green {
            background-color: #0f0;
            box-shadow: 0 0 5px #0f0;
        }

        .status-dot.yellow {
            background-color: #ff0;
            box-shadow: 0 0 5px #ff0;
        }

        #network-notice {
            padding: 10px;
            background: #ff6600;
            color: #000;
            text-align: center;
            cursor: pointer;
            display: none;
            font-weight: bold;
        }

        #network-notice:hover {
            background: #ff8800;
        }
    </style>
</head>

<body>
    <div id="header">
        <span id="status">Initializing WebVM...</span>
        <div id="network-status">
            <span>Bridge:</span>
            <div id="bridge-dot" class="status-dot red" title="Host Bridge Disconnected"></div>
        </div>
        <div>
            <button onclick="injectDirectClient()">Inject Client</button>
            <button onclick="runClientAsRoot()" style="background: #a33; color: white;">Run Root üöÄ</button>
            <button id="inject-btn"
                style="padding: 2px 8px; cursor: pointer; background: #666; color: white; border: none; margin-right: 5px;">
                Inject Bridge (Old)</button>
            <button id="paste-btn" style="padding: 2px 8px; cursor: pointer;">üìã Paste</button>
        </div>
    </div>
    <div id="network-notice">‚ö†Ô∏è Click here to enable networking (Tailscale authentication required)</div>
    <div id="console"></div>
    <script>
        // --- Host-Local Bridge Configuration ---
        const BRIDGE_WS_URL = "ws://localhost:8082";

        const PYTHON_CLIENT_SRC = `#!/usr/bin/env python3
import time
import os
import struct
import sys
import base64

# Protocol Config: CONSOLE BRIDGE V3
# VM -> JS: Print to stdout [[BRIDGE:<base64>]]
# JS -> VM: Write to /root/host_to_vm

BASE_DIR = "/root"
PIPE_IN  = os.path.join(BASE_DIR, "host_to_vm")

# Opcodes
OP_CONNECT = 0x01
OP_DATA    = 0x02
OP_CLOSE   = 0x03

def log(msg):
    # Standard logs go to stderr to avoid confusing the bridge parser
    sys.stderr.write(f"[DirectClient] {msg}\\n")
    sys.stderr.flush()

def ensure_files():
    pass

def send_frame(opcode, payload=b""):
    # Format: [OPCODE:1][LEN:4][PAYLOAD]
    conn_id = 999 
    packet = struct.pack('>IBI', conn_id, opcode, len(payload)) + payload
    
    # ENCODE ADDRESS TO STDOUT
    b64 = base64.b64encode(packet).decode('ascii')
    # Print with marker. flush=True is critical.
    print(f"[[BRIDGE:{b64}]]", flush=True)

def read_response(offset, timeout=5):
    start = time.time()
    while time.time() - start < timeout:
        if os.path.exists(PIPE_IN):
            try:
                with open(PIPE_IN, "rb") as f:
                    f.seek(0, 2)
                    file_size = f.tell()
                    if file_size > offset:
                        f.seek(offset)
                        data = f.read()
                        new_offset = offset + len(data)
                        return data, new_offset
            except: pass
        time.sleep(0.1)
    return None, offset

def main():
    target_host = "google.com"
    target_port = 80
    log(f"Connecting to {target_host} via CONSOLE BRIDGE...")
    ensure_files()
    
    host_bytes = target_host.encode()
    payload = struct.pack(f'>H{len(host_bytes)}sH', len(host_bytes), host_bytes, target_port)
    send_frame(OP_CONNECT, payload)
    
    log("Sent CONNECT. Sending GET...")
    time.sleep(1.0) 
    
    request = f"GET / HTTP/1.1\\r\\nHost: {target_host}\\r\\nConnection: close\\r\\n\\r\\n".encode()
    send_frame(OP_DATA, request)
    
    log("Waiting for response...")
    total = b""
    buf = b""
    off = 0
    start = time.time()
    
    # Simple loop to pump data
    while time.time() - start < 10:
        chunk, off = read_response(off, 1)
        if chunk:
            buf += chunk
            while len(buf) >= 9:
                cid, op, pf_len = struct.unpack('>IBI', buf[:9])
                if len(buf) < 9 + pf_len: break
                payload = buf[9:9+pf_len]
                buf = buf[9+pf_len:]
                if cid != 999: continue
                if op == OP_DATA: total += payload
                elif op == OP_CLOSE: 
                    log("Connection closed")
                    start = 0 
                    break
        else: pass
             
    if total:
        log("SUCCESS! Response:")
        # Print to stderr for visibility
        err_msg = total.decode('utf-8', errors='ignore')[:500]
        sys.stderr.write("-" * 40 + "\\n")
        sys.stderr.write(err_msg + "...\\n")
        sys.stderr.write("-" * 40 + "\\n")
    else: log("FAILED: No data.")

if __name__ == "__main__":
    main()
`;

        // Connection Map: ID -> WebSocket
        const connections = new Map();

        // Update UI
        function setBridgeStatus(connected) {
            const dot = document.getElementById('bridge-dot');
            if (connected) {
                dot.className = "status-dot green";
                dot.title = "Host Bridge Connected";
            } else {
                dot.className = "status-dot red";
                dot.title = "Host Bridge Disconnected";
            }
        }

        // --- Data Pump Logic ---

        async function sendToVm(data) {
            if (window.cx) {
                try {
                    // Write to /root/host_to_vm using cx.run
                    // We use UID 0 to ensure permissions are good

                    let binary = '';
                    for (let i = 0; i < data.length; i++) {
                        binary += String.fromCharCode(data[i]);
                    }
                    const b64 = btoa(binary);

                    await window.cx.run("/bin/sh", ["-c", `echo "${b64}" | base64 -d >> /root/host_to_vm`], { uid: 0, gid: 0 });

                } catch (e) {
                    console.error("Failed to write to bridge:", e);
                }
            }
        }


        // CONSOLE OBSERVER for VM -> JS
        function setupConsoleBridge() {
            const consoleEl = document.getElementById('console');

            // We need to parse [[BRIDGE:base64]]
            // Content might be added in chunks
            let buffer = "";

            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.addedNodes.length) {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE) {
                                buffer += node.textContent;
                            }
                        });
                    }
                });
                // Process after collecting updates
                processConsoleBuffer();
            });

            observer.observe(consoleEl, { childList: true, subtree: true, characterData: true });
            console.log("Console Bridge Observer Attached.");

            function processConsoleBuffer() {
                // Iterative parser to handle nested/interleaved tags
                // Pattern: Find "[[BRIDGE:"
                // Check if another "[[BRIDGE:" occurs before "]]" -> If so, discard first start.

                let startIndex = buffer.indexOf('[[BRIDGE:');

                while (startIndex !== -1) {
                    // Look for End Tag
                    const endIndex = buffer.indexOf(']]', startIndex);

                    if (endIndex === -1) {
                        // No end tag yet. 
                        // BUT check if there is a NEW start tag after current start?
                        // If so, the current start is likely garbage or part of a print that got interrupted?
                        // Actually, let's just wait for more data.
                        break;
                    }

                    // We have Start and End.
                    // Check for nested Start
                    const nextStart = buffer.indexOf('[[BRIDGE:', startIndex + 9);

                    if (nextStart !== -1 && nextStart < endIndex) {
                        // Found [[BRIDGE: inside!
                        // The first one was likely partial/garbage output or previous line echo.
                        // Discard up to nextStart
                        console.warn("[Bridge] Nested tag found, discarding prefix");
                        buffer = buffer.substring(nextStart); // Shift buffer
                        startIndex = 0; // Reset look from 0 (which is now nextStart)
                        continue;
                    }

                    // Valid Packet Candidate: buffer[startIndex...endIndex+2]
                    let b64 = buffer.substring(startIndex + 9, endIndex);

                    // Sanitize base64: remove newlines/spaces
                    b64 = b64.replace(/[\s\r\n]+/g, '');

                    // Process it
                    try {
                        const binStr = atob(b64);
                        const data = new Uint8Array(binStr.length);
                        for (let i = 0; i < binStr.length; i++) data[i] = binStr.charCodeAt(i);

                        console.log(`[Bridge] Parsed ${data.length} bytes from Console`);

                        // Handle
                        handleVmPacketFromConsole(data);

                    } catch (e) {
                        console.error("Bridge Decode Error:", e, b64);
                    }

                    // Remove this processed chunk from buffer
                    // We remove everything up to endIndex + 2
                    buffer = buffer.substring(endIndex + 2);

                    // Re-scan from new buffer start
                    startIndex = buffer.indexOf('[[BRIDGE:');
                }

                // Trim buffer if too large and no start tag
                if (buffer.length > 50000 && buffer.indexOf('[[BRIDGE:') === -1) {
                    buffer = buffer.slice(-1000);
                }
            }
        }

        let vmToJsBuffer = new Uint8Array(0);
        function appendBuffer(buffer, data) {
            const newBuffer = new Uint8Array(buffer.length + data.length);
            newBuffer.set(buffer);
            newBuffer.set(data, buffer.length);
            return newBuffer;
        }

        function handleVmPacketFromConsole(chunk) {
            vmToJsBuffer = appendBuffer(vmToJsBuffer, chunk);
            processVmBuffer();
        }

        function processVmBuffer() {
            // Parse: [CONN_ID:4][OPCODE:1][LEN:4][PAYLOAD]
            // Header size = 9 bytes

            while (vmToJsBuffer.length >= 9) {
                const view = new DataView(vmToJsBuffer.buffer);
                const connId = view.getUint32(0, false); // Big Endian
                const opcode = view.getUint8(4);
                const len = view.getUint32(5, false); // Big Endian

                if (vmToJsBuffer.length < 9 + len) {
                    return;
                }
                const payload = vmToJsBuffer.slice(9, 9 + len);
                vmToJsBuffer = vmToJsBuffer.slice(9 + len);
                handleVmPacket(connId, opcode, payload);
            }
        }

        function handleVmPacket(connId, opcode, payload) {
            let ws = connections.get(connId);

            if (opcode === 1) { // CONNECT
                if (ws) ws.close();
                try {
                    ws = new WebSocket(BRIDGE_WS_URL);
                    ws.binaryType = "arraybuffer";
                    connections.set(connId, ws);

                    ws.onopen = () => {
                        setBridgeStatus(true);
                        const packet = new Uint8Array(1 + payload.length);
                        packet[0] = 1;
                        packet.set(payload, 1);
                        console.log(`[Bridge] Sending to WS Proxy: CONNECT`);
                        ws.send(packet);
                    };

                    ws.onmessage = (event) => {
                        const data = new Uint8Array(event.data);
                        if (data.length < 1) return;
                        const wsOpcode = data[0];
                        const wsPayload = data.slice(1);

                        const vmPacket = new Uint8Array(9 + wsPayload.length);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, wsOpcode);
                        view.setUint32(5, wsPayload.length, false);
                        vmPacket.set(wsPayload, 9);
                        sendToVm(vmPacket);
                    };

                    ws.onclose = (e) => {
                        console.log(`[Bridge] WS Closed: Code=${e.code} Reason=${e.reason}`);
                        connections.delete(connId);
                        if (connections.size === 0) setBridgeStatus(false);
                        const vmPacket = new Uint8Array(9);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, 3); // CLOSE
                        view.setUint32(5, 0, false);
                        sendToVm(vmPacket);
                    };

                    ws.onerror = (e) => {
                        console.error("WS Error:", e);
                        const vmPacket = new Uint8Array(9);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, 0x81); // ERROR
                        view.setUint32(5, 0, false);
                        sendToVm(vmPacket);
                    };
                } catch (e) { console.error("WS Error", e); }
            } else if (opcode === 2) { // DATA
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const packet = new Uint8Array(1 + payload.length);
                    packet[0] = 2;
                    packet.set(payload, 1);
                    ws.send(packet);
                } else {
                    console.warn("[Bridge] Cannot send DATA, WS not open. State:", ws ? ws.readyState : "null");
                }
            } else if (opcode === 3) { // CLOSE
                if (ws) { ws.close(); connections.delete(connId); }
            }
        }


        async function injectDirectClient() {
            try {
                console.log("Injecting direct_client.py via cx.run (UID 0)...");
                const b64 = btoa(PYTHON_CLIENT_SRC);
                const rootOpts = { uid: 0, gid: 0 };

                // 1. Write Source as Root in /root/direct_client.py
                await window.cx.run("/bin/sh", ["-c", `echo "${b64}" | base64 -d > /root/direct_client.py`], rootOpts);

                // 2. Init HOST_TO_VM File (VM reads this)
                await window.cx.run("/bin/sh", ["-c", "> /root/host_to_vm"], rootOpts);

                // 3. Chmod 666 host_to_vm so VM user can read/write
                // We trust standard chown works on overlay
                await window.cx.run("/bin/chmod", ["666", "/root/host_to_vm"], rootOpts);

                console.log("Provisioning complete.");
                document.getElementById('status').innerText = "Client Injected (Console Bridge V3). Ready to Run.";

            } catch (e) {
                console.error("Injection Error:", e);
                document.getElementById('status').innerText = "Injection Failed: " + e;
            }
        }

        async function runClientAsRoot() {
            console.log("Running client via cx.run (root)...");
            try {
                const proc = await window.cx.run("/usr/bin/python3", ["/root/direct_client.py"], {
                    env: ["PYTHONPATH=/opt/python-packages"],
                    uid: 0, gid: 0
                });
                console.log("Client process finished with:", proc);
            } catch (e) {
                console.error("Run error:", e);
            }
        }

        async function injectVmNetScript() {
            alert("Use Inject Client instead.");
        }

        async function run() {
            try {
                // ... same loading ...
                document.getElementById('status').innerText = "Loading base system...";
                const baseDevice = await CheerpX.HttpBytesDevice.create("base.ext2").catch(e => { throw new Error(e.message); });
                const baseOverlay = await CheerpX.OverlayDevice.create(baseDevice, await CheerpX.IDBDevice.create("base_cache"));
                console.log("‚úì base.ext2 loaded");

                const packagesDevice = await CheerpX.HttpBytesDevice.create("packages.ext2").catch(e => { throw new Error(e.message); });
                const packagesOverlay = await CheerpX.OverlayDevice.create(packagesDevice, await CheerpX.IDBDevice.create("packages_cache"));
                console.log("‚úì packages.ext2 loaded");

                const appDevice = await CheerpX.HttpBytesDevice.create("app.ext2").catch(e => { throw new Error(e.message); });
                const appOverlay = await CheerpX.OverlayDevice.create(appDevice, await CheerpX.IDBDevice.create("app_cache"));
                console.log("‚úì app.ext2 loaded");

                document.getElementById('status').innerText = "Initializing CheerpX...";

                // Initialize CheerpX
                const cx = await CheerpX.Linux.create({
                    mounts: [
                        { type: "ext2", path: "/", dev: baseOverlay },
                        { type: "ext2", path: "/opt/python-packages", dev: packagesOverlay },
                        { type: "ext2", path: "/root/L.O.V.E", dev: appOverlay },
                        { type: "devs", path: "/dev" },
                        { type: "proc", path: "/proc" },
                    ],
                    networkInterface: { authKey: "", loginUrlCb: () => { }, stateUpdateCb: () => { } }
                });

                document.getElementById('status').innerText = "System Ready";

                window.cx = cx;
                window.fsDevice = baseOverlay;

                setupConsoleBridge(); // Start Console Interceptor

                window.injectCommand = function (command) {
                    if (!window.cx) return;
                    const consoleEl = document.getElementById('console');
                    if (consoleEl) {
                        const sendChar = (char) => {
                            const opts = { key: char, code: `Key${char.toUpperCase()}`, charCode: char.charCodeAt(0), keyCode: char.charCodeAt(0), which: char.charCodeAt(0), bubbles: true, cancelable: true, view: window };
                            consoleEl.dispatchEvent(new KeyboardEvent('keydown', opts));
                            consoleEl.dispatchEvent(new KeyboardEvent('keypress', opts));
                            consoleEl.dispatchEvent(new KeyboardEvent('keyup', opts));
                            const textEvent = document.createEvent('TextEvent');
                            textEvent.initTextEvent('textInput', true, true, window, char, 0, "en-US");
                            consoleEl.dispatchEvent(textEvent);
                        };
                        for (let char of command) sendChar(char);
                    }
                };

                document.getElementById('paste-btn').onclick = async () => {
                    try {
                        const text = await navigator.clipboard.readText();
                        if (text) {
                            window.injectCommand(text);
                        }
                    } catch (err) {
                        console.error('Failed to read clipboard:', err);
                        alert('Failed to read clipboard. Please allow clipboard access.');
                    }
                };

                console.log("%c‚úì CheerpX ready!", "color: #0f0; font-weight: bold");
                await cx.setConsole(document.getElementById('console'));
                await cx.run("/bin/bash", ["-l"], {
                    env: ["HOME=/root", "TERM=xterm", "PYTHONUNBUFFERED=1", "PYTHONDONTWRITEBYTECODE=1", "PYTHONPATH=/opt/python-packages", "PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin"],
                    cwd: "/root"
                });

                setTimeout(() => { injectDirectClient(); }, 5000);
                document.getElementById('status').innerText = "Process Finished.";
            } catch (e) {
                document.getElementById('status').innerText = "Error: " + e;
                console.error(e);
            }
        }

        run();
    </script>
</body>

</html>