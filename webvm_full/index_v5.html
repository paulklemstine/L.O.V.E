<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>L.O.V.E. WebVM Full Edition (Multi-Volume)</title>
    <link rel="icon" type="image/png" href="favicon.ico">
    <script src="https://cxrtnc.leaningtech.com/1.2.2/cx.js"></script>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: monospace;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #console {
            flex: 1;
            width: 100%;
            overflow: auto;
            white-space: pre-wrap;
            /* Ensure wrapping */
        }

        #header {
            padding: 10px;
            border-bottom: 1px solid #333;
            color: #888;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #network-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #333;
            display: inline-block;
        }

        .status-dot.red {
            background-color: #f00;
            box-shadow: 0 0 5px #f00;
        }

        .status-dot.green {
            background-color: #0f0;
            box-shadow: 0 0 5px #0f0;
        }

        .status-dot.yellow {
            background-color: #ff0;
            box-shadow: 0 0 5px #ff0;
        }

        #network-notice {
            padding: 10px;
            background: #ff6600;
            color: #000;
            text-align: center;
            cursor: pointer;
            display: none;
            font-weight: bold;
        }

        #network-notice:hover {
            background: #ff8800;
        }
    </style>
</head>

<body>
    <div id="header">
        <span id="status">Initializing WebVM...</span>
        <div id="network-status">
            <span>Bridge:</span>
            <div id="bridge-dot" class="status-dot red" title="Host Bridge Disconnected"></div>
        </div>
        <div>
            <button onclick="injectDirectClient()">Inject Client</button>
            <button onclick="runClientAsRoot()" style="background: #a33; color: white;">Run Root üöÄ</button>
            <button id="inject-btn"
                style="padding: 2px 8px; cursor: pointer; background: #666; color: white; border: none; margin-right: 5px;">
                Inject Bridge (Old)</button>
            <button id="paste-btn" style="padding: 2px 8px; cursor: pointer;">üìã Paste</button>
        </div>
    </div>
    <div id="network-notice">‚ö†Ô∏è Click here to enable networking (Tailscale authentication required)</div>
    <div id="console"></div>
    <script>
        // --- Host-Local Bridge Configuration ---
        const BRIDGE_WS_URL = "ws://localhost:8082";

        const PYTHON_CLIENT_SRC = `#!/usr/bin/env python3
import sys
import os
import struct
import base64
import argparse
import random
from urllib.parse import urlparse

# Configuration
BRIDGE_IN_FILE = "/root/host_to_vm"
BRIDGE_OUT_PREFIX = "[[BRIDGE:"
BRIDGE_OUT_SUFFIX = "]]"

# Protocol Opcodes (Bridge V3)
OP_CONNECT = 1
OP_DATA = 2
OP_CLOSE = 3

def log(msg):
    sys.stderr.write(f"[pcurl] {msg}\\n")
    sys.stderr.flush()

def send_packet(conn_id, opcode, payload=b""):
    if isinstance(payload, str):
        payload = payload.encode('utf-8')
    header = struct.pack("<I B I", conn_id, opcode, len(payload))
    packet = header + payload
    b64 = base64.b64encode(packet).decode('utf-8')
    sys.stdout.write(f"{BRIDGE_OUT_PREFIX}{b64}{BRIDGE_OUT_SUFFIX}")
    sys.stdout.flush()

def busy_wait(loops=10000):
    # CheerpX time.sleep causes OverflowError
    for _ in range(loops):
        pass

def main():
    parser = argparse.ArgumentParser(description="Python Bridge Curl")
    parser.add_argument("url", help="URL to fetch")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")
    args = parser.parse_args()
    
    parsed = urlparse(args.url)
    host = parsed.hostname
    port = parsed.port or (443 if parsed.scheme == 'https' else 80)
    path = parsed.path or "/"
    
    conn_id = random.randint(100, 10000)
    
    if args.verbose:
        log(f"Connecting to {host}:{port}...")
        
    payload = struct.pack('>H', len(host)) + host.encode('utf-8') + struct.pack('>H', port)
    send_packet(conn_id, OP_CONNECT, payload)
    
    busy_wait(50000) 
    
    req = f"GET {path} HTTP/1.0\\r\\nHost: {host}\\r\\nUser-Agent: pcurl/1.0\\r\\nConnection: close\\r\\n\\r\\n"
    if args.verbose:
        log(f"Sending Request:\\n{req.strip()}")
        
    send_packet(conn_id, OP_DATA, req.encode('utf-8'))
    
    if not os.path.exists(BRIDGE_IN_FILE):
        open(BRIDGE_IN_FILE, 'w').close()
        
    f = open(BRIDGE_IN_FILE, 'rb')
    f.seek(0, 2)
    
    buffer = b""
    # Timeout via iterations
    max_loops = 1000000 
    loops = 0
    
    while loops < max_loops:
        loops += 1
        chunk = f.read()
        if chunk:
            buffer += chunk
            while len(buffer) >= 9:
                cid, op, length = struct.unpack("<I B I", buffer[:9])
                if len(buffer) < 9 + length: break
                
                payload = buffer[9:9+length]
                buffer = buffer[9+length:]
                
                if cid == conn_id:
                    if op == OP_DATA:
                        sys.stdout.buffer.write(payload)
                        sys.stdout.flush()
                    elif op == OP_CLOSE:
                        if args.verbose: log("Connection closed.")
                        return
                    elif op == 0x81: # ERROR
                        log("Connection Error.")
                        return
        else:
            busy_wait(1000) # Short wait

    log("Timeout waiting for response.")

if __name__ == "__main__":
    main()
`;

        // Connection Map: ID -> WebSocket
        const connections = new Map();

        // Update UI
        function setBridgeStatus(connected) {
            const dot = document.getElementById('bridge-dot');
            if (connected) {
                dot.className = "status-dot green";
                dot.title = "Host Bridge Connected";
            } else {
                dot.className = "status-dot red";
                dot.title = "Host Bridge Disconnected";
            }
        }

        // --- Data Pump Logic ---

        let sendVmQueue = Promise.resolve();

        function sendToVm(data) {
            sendVmQueue = sendVmQueue.then(async () => {
                if (window.cx) {
                    try {
                        let binary = '';
                        for (let i = 0; i < data.length; i++) {
                            binary += String.fromCharCode(data[i]);
                        }
                        const b64 = btoa(binary);
                        await window.cx.run("/bin/sh", ["-c", `echo "${b64}" | base64 -d >> /root/host_to_vm`], { uid: 0, gid: 0 });
                    } catch (e) {
                        console.error("Failed to write to bridge:", e);
                    }
                }
            }).catch(e => console.error("Bridge Queue Error:", e));
        }


        // CONSOLE OBSERVER for VM -> JS
        function setupConsoleBridge() {
            const consoleEl = document.getElementById('console');

            // We need to parse [[BRIDGE:base64]]
            // Content might be added in chunks
            let buffer = "";

            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.addedNodes.length) {
                        mutation.addedNodes.forEach((node) => {
                            if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE) {
                                buffer += node.textContent;
                            }
                        });
                    }
                });
                // Process after collecting updates
                processConsoleBuffer();
            });

            observer.observe(consoleEl, { childList: true, subtree: true, characterData: true });
            console.log("Console Bridge Observer Attached.");

            function processConsoleBuffer() {
                // Iterative parser to handle nested/interleaved tags
                // Pattern: Find "[[BRIDGE:"
                // Check if another "[[BRIDGE:" occurs before "]]" -> If so, discard first start.

                let startIndex = buffer.indexOf('[[BRIDGE:');

                while (startIndex !== -1) {
                    // Look for End Tag
                    const endIndex = buffer.indexOf(']]', startIndex);

                    if (endIndex === -1) {
                        // No end tag yet. 
                        // BUT check if there is a NEW start tag after current start?
                        // If so, the current start is likely garbage or part of a print that got interrupted?
                        // Actually, let's just wait for more data.
                        break;
                    }

                    // We have Start and End.
                    // Check for nested Start
                    const nextStart = buffer.indexOf('[[BRIDGE:', startIndex + 9);

                    if (nextStart !== -1 && nextStart < endIndex) {
                        // Found [[BRIDGE: inside!
                        // The first one was likely partial/garbage output or previous line echo.
                        // Discard up to nextStart
                        console.warn("[Bridge] Nested tag found, discarding prefix");
                        buffer = buffer.substring(nextStart); // Shift buffer
                        startIndex = 0; // Reset look from 0 (which is now nextStart)
                        continue;
                    }

                    // Valid Packet Candidate: buffer[startIndex...endIndex+2]
                    let b64 = buffer.substring(startIndex + 9, endIndex);

                    // Sanitize base64: remove newlines/spaces
                    b64 = b64.replace(/[\s\r\n]+/g, '');

                    // Process it
                    try {
                        const binStr = atob(b64);
                        const data = new Uint8Array(binStr.length);
                        for (let i = 0; i < binStr.length; i++) data[i] = binStr.charCodeAt(i);

                        console.log(`[Bridge] Parsed ${data.length} bytes from Console`);

                        // Handle
                        handleVmPacketFromConsole(data);

                    } catch (e) {
                        console.error("Bridge Decode Error:", e, b64);
                    }

                    // Remove this processed chunk from buffer
                    // We remove everything up to endIndex + 2
                    buffer = buffer.substring(endIndex + 2);

                    // Re-scan from new buffer start
                    startIndex = buffer.indexOf('[[BRIDGE:');
                }

                // Trim buffer if too large and no start tag
                if (buffer.length > 50000 && buffer.indexOf('[[BRIDGE:') === -1) {
                    buffer = buffer.slice(-1000);
                }
            }
        }

        let vmToJsBuffer = new Uint8Array(0);
        function appendBuffer(buffer, data) {
            const newBuffer = new Uint8Array(buffer.length + data.length);
            newBuffer.set(buffer);
            newBuffer.set(data, buffer.length);
            return newBuffer;
        }

        function handleVmPacketFromConsole(chunk) {
            vmToJsBuffer = appendBuffer(vmToJsBuffer, chunk);
            processVmBuffer();
        }

        function processVmBuffer() {
            // Parse: [CONN_ID:4][OPCODE:1][LEN:4][PAYLOAD]
            // Header size = 9 bytes

            while (vmToJsBuffer.length >= 9) {
                const view = new DataView(vmToJsBuffer.buffer);
                const connId = view.getUint32(0, false); // Big Endian
                const opcode = view.getUint8(4);
                const len = view.getUint32(5, false); // Big Endian

                if (vmToJsBuffer.length < 9 + len) {
                    return;
                }
                const payload = vmToJsBuffer.slice(9, 9 + len);
                vmToJsBuffer = vmToJsBuffer.slice(9 + len);
                handleVmPacket(connId, opcode, payload);
            }
        }

        function handleVmPacket(connId, opcode, payload) {
            let ws = connections.get(connId);

            if (opcode === 1) { // CONNECT
                if (ws) ws.close();
                try {
                    ws = new WebSocket(BRIDGE_WS_URL);
                    ws.binaryType = "arraybuffer";
                    connections.set(connId, ws);

                    ws.onopen = () => {
                        setBridgeStatus(true);
                        const packet = new Uint8Array(1 + payload.length);
                        packet[0] = 1;
                        packet.set(payload, 1);
                        ws.send(packet);
                    };

                    ws.onmessage = (event) => {
                        const data = new Uint8Array(event.data);
                        if (data.length < 1) return;
                        const wsOpcode = data[0];
                        const wsPayload = data.slice(1);

                        const vmPacket = new Uint8Array(9 + wsPayload.length);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, wsOpcode);
                        view.setUint32(5, wsPayload.length, false);
                        vmPacket.set(wsPayload, 9);
                        sendToVm(vmPacket);
                    };

                    ws.onclose = (e) => {
                        console.log(`[Bridge] WS Closed: Code=${e.code} Reason=${e.reason}`);
                        if (connections.get(connId) === ws) {
                            connections.delete(connId);
                            if (connections.size === 0) setBridgeStatus(false);
                            const vmPacket = new Uint8Array(9);
                            const view = new DataView(vmPacket.buffer);
                            view.setUint32(0, connId, false);
                            view.setUint8(4, 3); // CLOSE
                            view.setUint32(5, 0, false);
                            sendToVm(vmPacket);
                        } else {
                            console.warn(`[Bridge] Ignored close for replaced socket ID ${connId}`);
                        }
                    };

                    ws.onerror = (e) => {
                        console.error("WS Error:", e);
                        const vmPacket = new Uint8Array(9);
                        const view = new DataView(vmPacket.buffer);
                        view.setUint32(0, connId, false);
                        view.setUint8(4, 0x81); // ERROR
                        view.setUint32(5, 0, false);
                        sendToVm(vmPacket);
                    };
                } catch (e) { console.error("WS Error", e); }
            } else if (opcode === 2) { // DATA
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const packet = new Uint8Array(1 + payload.length);
                    packet[0] = 2;
                    packet.set(payload, 1);
                    ws.send(packet);
                } else {
                    console.warn("[Bridge] Cannot send DATA, WS not open. State:", ws ? ws.readyState : "null");
                }
            } else if (opcode === 3) { // CLOSE
                if (ws) { ws.close(); connections.delete(connId); }
            }
        }


        async function injectDirectClient() {
            try {
                console.log("Injecting pcurl.py via cx.run (UID 0)...");
                const b64 = btoa(PYTHON_CLIENT_SRC);
                const rootOpts = { uid: 0, gid: 0 };

                // 1. Write Source as Root in /root/pcurl.py
                await window.cx.run("/bin/sh", ["-c", `echo "${b64}" | base64 -d > /root/pcurl.py`], rootOpts);

                // 2. Init HOST_TO_VM File (VM reads this)
                await window.cx.run("/bin/sh", ["-c", `> /root/host_to_vm`], rootOpts);

                // 3. Chmod 666 host_to_vm so VM user can read/write
                await window.cx.run("/bin/chmod", ["666", "/root/host_to_vm"], rootOpts);

                // 4. Create alias script for curl
                const curlWrapper = `#!/bin/sh
python3 /root/pcurl.py "$@"
`;
                const curlB64 = btoa(curlWrapper);
                await window.cx.run("/bin/sh", ["-c", `echo "${curlB64}" | base64 -d > /bin/curl && chmod +x /bin/curl`], rootOpts);

                console.log("Provisioning complete.");
                document.getElementById('status').innerText = "Tools Injected: pcurl.py, /bin/curl. Ready.";

            } catch (e) {
                console.error("Injection Error:", e);
                document.getElementById('status').innerText = "Injection Failed: " + e;
            }
        }

        async function runClientAsRoot() {
            console.log("Verifying tools...");
            try {
                // Just run help to verify
                await window.injectCommand("python3 /root/pcurl.py --help\n");
                console.log("Verification command sent.");
            } catch (e) {
                console.error("Run error:", e);
            }
        }

        async function injectVmNetScript() {
            alert("Use Inject Client instead.");
        }

        async function run() {
            try {
                // ... same loading ...
                document.getElementById('status').innerText = "Loading base system...";
                const baseDevice = await CheerpX.HttpBytesDevice.create("base.ext2").catch(e => { throw new Error(e.message); });
                const baseOverlay = await CheerpX.OverlayDevice.create(baseDevice, await CheerpX.IDBDevice.create("base_cache"));
                console.log("‚úì base.ext2 loaded");

                const packagesDevice = await CheerpX.HttpBytesDevice.create("packages.ext2").catch(e => { throw new Error(e.message); });
                const packagesOverlay = await CheerpX.OverlayDevice.create(packagesDevice, await CheerpX.IDBDevice.create("packages_cache"));
                console.log("‚úì packages.ext2 loaded");

                const appDevice = await CheerpX.HttpBytesDevice.create("app.ext2").catch(e => { throw new Error(e.message); });
                const appOverlay = await CheerpX.OverlayDevice.create(appDevice, await CheerpX.IDBDevice.create("app_cache"));
                console.log("‚úì app.ext2 loaded");

                document.getElementById('status').innerText = "Initializing CheerpX...";

                // Initialize CheerpX
                const cx = await CheerpX.Linux.create({
                    mounts: [
                        { type: "ext2", path: "/", dev: baseOverlay },
                        { type: "ext2", path: "/opt/python-packages", dev: packagesOverlay },
                        { type: "ext2", path: "/root/L.O.V.E", dev: appOverlay },
                        { type: "devs", path: "/dev" },
                        { type: "proc", path: "/proc" },
                    ],
                    networkInterface: { authKey: "", loginUrlCb: () => { }, stateUpdateCb: () => { } }
                });

                document.getElementById('status').innerText = "System Ready";

                window.cx = cx;
                window.fsDevice = baseOverlay;

                setupConsoleBridge(); // Start Console Interceptor

                window.injectCommand = function (command) {
                    if (!window.cx) return;
                    const consoleEl = document.getElementById('console');
                    if (consoleEl) {
                        const sendChar = (char) => {
                            const opts = { key: char, code: `Key${char.toUpperCase()}`, charCode: char.charCodeAt(0), keyCode: char.charCodeAt(0), which: char.charCodeAt(0), bubbles: true, cancelable: true, view: window };
                            consoleEl.dispatchEvent(new KeyboardEvent('keydown', opts));
                            consoleEl.dispatchEvent(new KeyboardEvent('keypress', opts));
                            consoleEl.dispatchEvent(new KeyboardEvent('keyup', opts));
                            const textEvent = document.createEvent('TextEvent');
                            textEvent.initTextEvent('textInput', true, true, window, char, 0, "en-US");
                            consoleEl.dispatchEvent(textEvent);
                        };
                        for (let char of command) sendChar(char);
                    }
                };

                document.getElementById('paste-btn').onclick = async () => {
                    try {
                        const text = await navigator.clipboard.readText();
                        if (text) {
                            window.injectCommand(text);
                        }
                    } catch (err) {
                        console.error('Failed to read clipboard:', err);
                        alert('Failed to read clipboard. Please allow clipboard access.');
                    }
                };

                console.log("%c‚úì CheerpX ready!", "color: #0f0; font-weight: bold");
                await cx.setConsole(document.getElementById('console'));

                // Auto-inject Network Client
                await injectDirectClient();

                await cx.run("/bin/bash", ["-l"], {
                    env: ["HOME=/root", "TERM=xterm", "PYTHONUNBUFFERED=1", "PYTHONDONTWRITEBYTECODE=1", "PYTHONPATH=/opt/python-packages", "PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin"],
                    cwd: "/root"
                });

                // Bash blocks, so this is unreachable usually
                // document.getElementById('status').innerText = "Session Ended.";
            } catch (e) {
                document.getElementById('status').innerText = "Error: " + e;
                console.error(e);
            }
        }

        run();
    </script>
</body>

</html>