/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d6090697-1947-4da3-8034-e90d7a3f6e3c
-/

/-
We define `is_solution x y` as the proposition that `y` satisfies the equation $0 = \cos(2\pi\sqrt{x}) - \cos(2\pi\sqrt{x+y})$ and the domain constraint $x+y \ge 0$.
We prove in `solution_set_eq` that for $x \ge 0$, the set of such `y` is exactly $\{ (k + \sqrt{x})^2 - x \mid k \in \mathbb{Z} \}$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The set of solutions y (where x+y >= 0) to the equation 0 = cos(sqrt(x)*2*pi) - cos(sqrt(x+y)*2*pi) is the set of values (k + sqrt(x))^2 - x for integers k.
-/
def is_solution (x y : Real) : Prop :=
  0 ≤ x + y ∧ 0 = Real.cos (Real.sqrt x * 2 * Real.pi) - Real.cos (Real.sqrt (x + y) * 2 * Real.pi)

theorem solution_set_eq (x : Real) (hx : 0 ≤ x) :
  {y | is_solution x y} = {y | ∃ k : ℤ, y = (k + Real.sqrt x)^2 - x} := by
    ext y;
    constructor;
    · unfold is_solution;
      field_simp;
      intro hy;
      obtain ⟨k, hk⟩ : ∃ k : ℤ, Real.sqrt (x + y) = k + Real.sqrt x ∨ Real.sqrt (x + y) = -k - Real.sqrt x := by
        obtain ⟨ k, hk ⟩ := Real.cos_eq_cos_iff.mp ( show Real.cos ( Real.sqrt x * 2 * Real.pi ) = Real.cos ( 2 * Real.pi * Real.sqrt ( x + y ) ) by linarith [ hy.symm ] );
        rcases hk with ( hk | hk ) <;> [ exact ⟨ k, Or.inl <| by nlinarith [ Real.pi_pos ] ⟩ ; exact ⟨ -k, Or.inr <| by push_cast; nlinarith [ Real.pi_pos ] ⟩ ];
      grind;
    · rintro ⟨ k, rfl ⟩;
      constructor <;> norm_num;
      · positivity;
      · rw [ Real.sqrt_sq_eq_abs ] ; cases abs_cases ( k + Real.sqrt x ) <;> simp +decide [ *, mul_assoc, mul_left_comm ] ; ring_nf;
        · norm_num [ mul_assoc, mul_comm Real.pi ];
        · rw [ Real.cos_sub_cos ] ; ring ; norm_num;
          exact Or.inl ( Real.sin_eq_zero_iff.mpr ⟨ k, by ring ⟩ )