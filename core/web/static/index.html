<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L.O.V.E. v2 - DeepAgent Control Panel</title>
    <style>
        :root {
            --bg-color: #0d0d0d;
            --text-color: #e0e0e0;
            --accent-color: #00ffff;
            --secondary-color: #ff00ff;
            --panel-bg: #1a1a1a;
            --success: #00ff00;
            --error: #ff0000;
            --warning: #ffff00;
            --dim-text: #888;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            grid-template-rows: auto 1fr auto;
            gap: 20px;
            height: 100vh;
            box-sizing: border-box;
        }

        header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 10px;
        }

        h1 {
            margin: 0;
            color: var(--accent-color);
            text-shadow: 0 0 10px var(--accent-color);
        }

        h2 {
            margin-top: 0;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            font-size: 1.2em;
            color: var(--secondary-color);
        }

        h3 {
            font-size: 1em;
            margin-bottom: 5px;
            color: var(--accent-color);
        }

        .panel {
            background-color: var(--panel-bg);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #333;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #left-sidebar {
            grid-column: 1;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }

        #main-content {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #right-sidebar {
            grid-column: 3;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #status-panel,
        #memory-panel {
            background: var(--panel-bg);
        }

        .stat-item {
            margin-bottom: 10px;
        }

        .stat-label {
            color: var(--dim-text);
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 1.1em;
            font-weight: bold;
        }

        .running {
            color: var(--success);
        }

        .stopped {
            color: var(--error);
        }

        #goal-display {
            background: #222;
            padding: 10px;
            border-left: 3px solid var(--secondary-color);
            margin-top: 5px;
            font-style: italic;
            font-size: 0.9em;
        }

        /* Agent Monitor */
        .agent-card {
            background: #252525;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
            border: 1px solid #444;
        }

        .agent-name {
            font-weight: bold;
            color: var(--accent-color);
            margin-bottom: 5px;
        }

        .agent-status {
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .agent-thought {
            font-size: 0.85em;
            color: #aaa;
            font-style: italic;
            border-top: 1px solid #444;
            padding-top: 5px;
            margin-top: 5px;
        }

        /* Art Panel */
        #art-display {
            width: 100%;
            aspect-ratio: 1;
            background: #000;
            border: 1px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #555;
            overflow: hidden;
        }

        #art-display img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Logs */
        #logs-panel {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        #log-container {
            flex-grow: 1;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            background: #0d0d0d;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #333;
            font-size: 0.9em;
        }

        .log-entry {
            margin-bottom: 4px;
            display: flex;
            gap: 10px;
            border-bottom: 1px solid #1a1a1a;
            padding-bottom: 2px;
        }

        .log-meta {
            flex-shrink: 0;
            width: 140px;
            font-size: 0.8em;
            color: #666;
            display: flex;
            flex-direction: column;
        }

        .log-content {
            flex-grow: 1;
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: break-word;
            /* Fixes long string overflow */
        }

        .log-level {
            font-weight: bold;
        }

        .INFO {
            color: #888;
        }

        .WARNING {
            color: var(--warning);
        }

        .ERROR {
            color: var(--error);
        }

        .source {
            color: var(--accent-color);
        }

        /* LLM Console */
        #llm-console {
            grid-column: 1 / -1;
            grid-row: 3;
            background: #151515;
            padding: 10px;
            border-top: 1px solid #333;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #llm-input {
            flex-grow: 1;
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-family: inherit;
        }

        button {
            background: var(--accent-color);
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            opacity: 0.9;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #111;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        /* Interaction Panel */
        .interaction-item {
            padding: 10px;
            border-bottom: 1px solid #333;
            font-size: 0.9em;
        }
        
        .interaction-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .interaction-author {
            font-weight: bold;
            color: var(--secondary-color);
        }
        
        .interaction-text {
            color: #ddd;
            margin-bottom: 4px;
        }
        
        .interaction-meta {
            font-size: 0.8em;
            color: #666;
        }

        /* Latest Post Text */
        .latest-post-content {
            margin-top: 10px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
            font-size: 0.9em;
            border-left: 2px solid var(--accent-color);
        }
        
        .latest-post-stats {
            display: flex;
            gap: 10px;
            margin-top: 5px;
            font-size: 0.8em;
            color: #888;
        }
    </style>
</head>

<body>
    <header>
        <h1>L.O.V.E. v2 Control Panel</h1>
        <div id="connection-status" style="color: var(--error)">Disconnected</div>
    </header>

    <div id="left-sidebar">
        <!-- System Status -->
        <div id="status-panel" class="panel">
            <h2>System Status</h2>
            <div class="stat-item">
                <div class="stat-label">Core State</div>
                <div id="agent-state" class="stat-value stopped">STOPPED</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Iteration</div>
                <div id="iteration-count" class="stat-value">0</div>
            </div>
            <div class="stat-label">Current Goal</div>
            <div id="goal-display">Waiting for goal...</div>
        </div>

        <!-- Active Agents -->
        <div id="agents-panel" class="panel">
            <h2>Active Agents</h2>
            <div id="agent-list">
                <div style="color: #666; font-style: italic;">No agents active yet...</div>
            </div>
        </div>
    </div>

    <div id="main-content">
        <!-- Live Logs -->
        <div id="logs-panel" class="panel">
            <h2>Live Logs</h2>
            <div id="log-container"></div>
        </div>
    </div>

    <div id="right-sidebar">
        <!-- Art/Visuals + Latest Post -->
        <div id="art-panel" class="panel">
            <h2>Latest Post</h2>
            <div id="art-display">
                <span>No Signal</span>
            </div>
            <div id="latest-post-text" class="latest-post-content" style="display:none;"></div>
        </div>

        <!-- Interactions Panel (Latest Comments/Replies) -->
        <div id="interactions-panel" class="panel" style="flex-grow: 1; min-height: 200px;">
            <h2>Live Comments</h2>
            <div id="interactions-list" style="overflow-y: auto; flex-grow: 1;">
                <div style="color: #666; font-style: italic; padding: 10px;">Waiting for signal...</div>
            </div>
        </div>
    </div>

    <!-- LLM Bridge -->
    <div id="llm-console">
        <div style="font-weight: bold; color: var(--secondary-color);">LLM Bridge:</div>
        <input type="text" id="llm-input" placeholder="Enter prompt for direct LLM generation..."
            onkeypress="handleEnter(event)">
        <button onclick="submitLLM()">Generate</button>
    </div>

    <script>
        const API_URL = "/api";
        const UPDATE_INTERVAL = 1000;
        let lastImageHash = "";

        async function fetchStatus() {
            try {
                const response = await fetch(`${API_URL}/status`);
                const data = await response.json();

                // Connection status
                document.getElementById('connection-status').textContent = 'Connected';
                document.getElementById('connection-status').style.color = '#00ff00';

                // Core Stats
                document.getElementById('agent-state').textContent = data.is_running ? "RUNNING" : "STOPPED";
                document.getElementById('agent-state').className = `stat-value ${data.is_running ? 'running' : 'stopped'}`;
                document.getElementById('iteration-count').textContent = data.iteration;

                const goal = data.current_goal || "No active goal";
                document.getElementById('goal-display').textContent = goal;

                // Agent List
                updateAgentList(data.agent_states);

                // Art/Image & Latest Post
                if (data.latest_post) {
                   const lp = data.latest_post;
                   
                   // Update image if present and new
                   if (lp.image_path) {
                       // Note: Fetching local image path via browser might not work without serving it.
                       // BUT, StateManager might also have last_image (b64) updated.
                       // Let's rely on data.last_image for the visual if available.
                   }
                   
                   const postTextDiv = document.getElementById('latest-post-text');
                   postTextDiv.style.display = 'block';
                   postTextDiv.innerHTML = `
                       <div>${escapeHtml(lp.text)}</div>
                       <div class="latest-post-stats">
                           <span>‚ù§Ô∏è ${lp.likes || 0}</span>
                           <span>üîÅ ${lp.reposts || 0}</span>
                           <span>üïí ${new Date(lp.timestamp).toLocaleTimeString()}</span>
                       </div>
                   `;
                }

                if (data.last_image && data.last_image !== lastImageHash) {
                    const artDisplay = document.getElementById('art-display');
                    artDisplay.innerHTML = `<img src="data:image/png;base64,${data.last_image}" alt="Generated Art" />`;
                    lastImageHash = data.last_image;
                }

                // Interactions
                if (data.interactions) {
                    updateInteractions(data.interactions);
                }

            } catch (error) {
                console.error("Status fetch failed:", error);
                document.getElementById('connection-status').textContent = 'Disconnected';
                document.getElementById('connection-status').style.color = '#ff0000';
            }
        }

        function updateAgentList(agentStates) {
            const container = document.getElementById('agent-list');
            if (!agentStates || Object.keys(agentStates).length === 0) {
                return; 
            }

            let html = '';
            // Track all agents
            for (const [name, state] of Object.entries(agentStates)) {
                html += `
                    <div class="agent-card">
                        <div class="agent-name">${name}</div>
                        <div class="agent-status">${state.status}</div>
                        ${state.action ? `<div style="color: var(--success); font-size: 0.9em;">‚ñ∂ ${state.action}</div>` : ''}
                        ${state.thought ? `<div class="agent-thought">"${state.thought}"</div>` : ''}
                    </div>
                `;
            }
            container.innerHTML = html;
        }

        function updateInteractions(interactions) {
            const container = document.getElementById('interactions-list');
            if (!interactions || interactions.length === 0) return;
            
            // Render list
            container.innerHTML = interactions.map(item => {
                const icon = item.reason === 'reply' ? 'üí¨' : item.reason === 'mention' ? 'üëã' : '‚ù§Ô∏è';
                return `
                    <div class="interaction-item">
                        <div class="interaction-header">
                            <span class="interaction-author">${icon} @${item.author.handle}</span>
                            <span class="interaction-meta">${new Date(item.timestamp).toLocaleTimeString()}</span>
                        </div>
                        <div class="interaction-text">${escapeHtml(item.text || "")}</div>
                    </div>
                `;
            }).join('');
        }

        async function fetchLogs() {
            try {
                const response = await fetch(`${API_URL}/logs?limit=100`);
                const logs = await response.json();

                const container = document.getElementById('log-container');
                const wasScrolledToBottom = container.scrollHeight - container.scrollTop <= container.clientHeight + 50;

                // Reverse logs: most recent at top
                container.innerHTML = logs.reverse().map(log => {
                    const time = new Date(log.timestamp).toLocaleTimeString();
                    return `
                        <div class="log-entry">
                            <div class="log-meta">
                                <div>${time}</div>
                                <div class="log-level ${log.level}">${log.level}</div>
                                <div class="source">${log.source}</div>
                            </div>
                            <div class="log-content">${escapeHtml(log.message)}</div>
                        </div>
                    `;
                }).join('');

                // Scroll only if user was near top (since we're adding to top now? No, we're replacing content)
                // Actually, if reversed, we usually want to see top.
                // But this replaces innerHTML.
                // Standard terminal: new at bottom. "Reverse" means new at top.
                // So scroll should be at TOP (0).
                // container.scrollTop = 0; 
                // However, user might scroll down to see history.
                // Let's leave scroll position alone if not 0.


                if (wasScrolledToBottom) {
                    container.scrollTop = container.scrollHeight;
                }
            } catch (error) {
                console.error("Log fetch failed:", error);
            }
        }

        function escapeHtml(text) {
            if (!text) return "";
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // LLM Bridge
        async function submitLLM() {
            const input = document.getElementById('llm-input');
            const prompt = input.value.trim();
            if (!prompt) return;

            console.log("Generating response for:", prompt);
            input.value = "Generating...";
            input.disabled = true;

            try {
                const response = await fetch(`${API_URL}/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: prompt })
                });
                const data = await response.json();

                if (data.error) {
                    alert("Error: " + data.error);
                } else {
                    console.log("LLM Response:", data.response);
                    // Also show in logs for visibility
                    // You could add a modal here if you wanted
                    alert(data.response);
                }
            } catch (e) {
                alert("Request failed: " + e);
            } finally {
                input.value = "";
                input.disabled = false;
                input.focus();
            }
        }

        function handleEnter(e) {
            if (e.key === 'Enter') submitLLM();
        }

        // Expose for debugging
        window.askLLM = async (prompt) => {
            document.getElementById('llm-input').value = prompt;
            await submitLLM();
        };

        // Initial load
        fetchStatus();
        fetchLogs();

        // Loop
        setInterval(() => {
            fetchStatus();
            fetchLogs();
        }, UPDATE_INTERVAL);
    </script>
</body>

</html>