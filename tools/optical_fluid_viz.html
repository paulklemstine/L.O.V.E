<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üëÅÔ∏è OMNI-VERSE ENGINE v3</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&display=swap');

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Rajdhani', sans-serif;
            color: #fff;
        }

        canvas#glcanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        canvas#freqcanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 60px;
            /* Width of the sidebar */
            height: 100%;
            z-index: 20;
            background: rgba(0, 0, 0, 0.5);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 60px;
            /* Offset for sidebar */
            width: calc(100% - 60px);
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #start-screen {
            background: rgba(0, 0, 0, 0.95);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            transition: opacity 1s ease;
        }

        h1 {
            font-size: 6rem;
            letter-spacing: 20px;
            margin: 0 0 20px 0;
            text-align: center;
            background: linear-gradient(90deg, #f0f, #0ff, #fff, #ff0, #f0f);
            background-size: 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbow 3s linear infinite;
        }

        @keyframes rainbow {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 100% 50%;
            }
        }

        button.start-btn {
            margin-top: 50px;
            padding: 20px 80px;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            font-size: 2rem;
            letter-spacing: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button.start-btn:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 40px #fff;
            transform: scale(1.1);
        }

        /* POST CARD */
        #post-card {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 40px;
            border-radius: 12px;
            width: 80%;
            max-width: 800px;
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        .handle {
            color: #0ff;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 2px;
            display: block;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0ff;
        }

        #post-text {
            font-size: 1.8rem;
            line-height: 1.4;
            font-weight: 500;
            text-shadow: 0 2px 5px #000;
        }

        #post-image {
            width: 100%;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* CONTROLS */
        #controls {
            position: absolute;
            bottom: 30px;
            left: 90px;
            /* Clears sidebar */
            z-index: 50;
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .ctrl-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 10px 20px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            letter-spacing: 2px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .ctrl-btn:hover {
            border-color: #0ff;
            color: #0ff;
            background: rgba(0, 255, 255, 0.1);
        }

        .ctrl-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .ctrl-label {
            font-size: 0.7rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        #status-display {
            margin-left: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 0 0 5px #000;
        }
    </style>
</head>

<body>

    <canvas id="glcanvas"></canvas>
    <canvas id="freqcanvas"></canvas>

    <div id="start-screen">
        <h1>OMNI-VERSE</h1>
        <p style="letter-spacing: 5px; color: #888;">VISUAL ENGINE v3.0</p>
        <button id="start-btn" class="start-btn">IGNITE</button>
    </div>

    <div id="ui-layer">
        <div id="post-card">
            <span class="handle">@e-v-l-o-v-e.bsky.social</span>
            <div id="post-text">Connecting to dimensionality matrix...</div>
            <img id="post-image" />
            <div id="post-date" style="text-align: right; margin-top: 15px; color: #888; font-size: 0.9rem;">SYSTEM
                READY</div>
        </div>
    </div>

    <div id="controls">
        <div class="ctrl-group">
            <span class="ctrl-label">LAYER A</span>
            <button class="ctrl-btn" onclick="cycleLayer(0)">CYCLE</button>
        </div>
        <div class="ctrl-group">
            <span class="ctrl-label">LAYER B</span>
            <button class="ctrl-btn" onclick="cycleLayer(1)">CYCLE</button>
        </div>
        <div class="ctrl-group">
            <span class="ctrl-label">SYSTEM</span>
            <button class="ctrl-btn" style="border-color: #f0f" onclick="forceReroll()">REROLL</button>
        </div>
        <div id="status-display">
            <span id="layer-a-name" style="color: #0ff">FLUID</span>
            <span id="layer-b-name" style="color: #f0f">FRACTAL</span>
        </div>
    </div>

    <!-- SHADERS -->
    <script id="vert" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="frag" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision highp float;
        #endif

        uniform float u_time;
        uniform vec2 u_resolution;
        uniform float u_params[16];
        uniform int u_layer1_type;
        uniform int u_layer2_type;

        #define PI 3.14159265359

        // --- UTILS ---
        mat2 rot(float a) {
            float s = sin(a), c = cos(a);
            return mat2(c, -s, s, c);
        }

        float hash(vec2 p) {
            vec3 p3  = fract(vec3(p.xyx) * 0.1031);
            p3 += dot(p3, p3.yzx + 33.33);
            return fract((p3.x + p3.y) * p3.z);
        }

        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            for (int i=0; i<5; i++) {
                v += a * noise(p);
                p *= 2.0;
                a *= 0.5;
            }
            return v;
        }

        // PALETTE
        vec3 elfPalette(float t) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 1.0, 1.0);
            vec3 d = vec3(0.263, 0.416, 0.557); 
            return a + b * cos(6.28318 * (c * t + d + vec3(0.0, 0.1, 0.2)));
        }

        // --- VISUAL LIBRARY (16 LAYERS) ---

        // 1. FLUID
        vec3 viz_fluid(vec2 uv, float t, float p1, float p2, float p3, float p4) {
             vec2 p = uv * (3.0 + p1); 
             vec2 q = vec2(fbm(p), fbm(p + vec2(5.2, 1.3)));
             vec2 r = vec2(fbm(p + 4.0*q + vec2(1.7, 9.2) + 0.15*t), fbm(p + 4.0*q + vec2(8.3, 2.8) - 0.12*t));
             float f = fbm(p + 4.0*r);
             return elfPalette(f * 3.0 + t * 0.1 + p3) * f * f * (1.5 + p4*2.0);
        }

        // 2. FRACTAL
        vec3 viz_fractal(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            uv *= 1.5 - p1*0.5;
            vec3 col = vec3(0.0);
            vec2 z = uv;
            float scale = 1.5 + p2 * 0.5;
            float angle = t * 0.1 + p3;
            float d = 100.0;
            for(int i=0; i<4; i++) {
                z = abs(z) - 0.5; z *= rot(angle); z *= scale;
                d = min(d, length(z) / pow(scale, float(i)));
            }
            return vec3(0.02 / max(d, 0.001) * (0.5 + p4)) * elfPalette(length(uv) + t);
        }

        // 3. ENTITY
        vec3 viz_entity(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            uv.x = abs(uv.x);
            vec2 eyeUV = uv - vec2(0.4, 0.2 * sin(t));
            float r = length(eyeUV);
            float f = sin(atan(eyeUV.y, eyeUV.x) * 10.0 + t) * cos(r * 20.0 - t*2.0);
            float pupil = smoothstep(0.1 + p1*0.2, 0.05, r);
            float iris = smoothstep(0.4, 0.3, r) - pupil;
            return (vec3(f * iris) * elfPalette(p3 + r)) + vec3(pupil);
        }

        // 4. HYPERCUBE
        vec3 viz_hypercube(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            uv *= rot(t * 0.2);
            vec2 gv = fract(uv * (2.0 + p1*2.0)) - 0.5;
            vec2 id = floor(uv * (2.0 + p1*2.0));
            float d = length(max(abs(gv) - 0.3, 0.0));
            float mask = smoothstep(0.03, 0.02, abs(d));
            return (vec3(mask) + vec3(0.05/length(gv)*p3)) * elfPalette(id.x + id.y + t*0.5 + p2) * (0.5+p4);
        }

        // 5. TUNNEL
        vec3 viz_tunnel(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float r = length(uv);
            float a = atan(uv.y, uv.x) + 1.0/(r+0.01)*sin(t*0.5);
            float u = 0.5/r + t * (0.5 + p1);
            float v = a/PI * (2.0 + floor(p2*5.0));
            float tex = step(0.5, fract(u)) * step(0.5, fract(v)) + step(0.9, fract(u))*2.0;
            return vec3(tex) * (r*r*2.0) * elfPalette(u + p3) * (0.5+p4);
        }

        // 6. FIRE
        vec3 viz_fire(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float n = fbm(uv * 3.0 + vec2(0.0, -t*(0.5+p1)));
            float intensity = pow(n * (1.0 - (uv.y+0.5)) * 2.0, 2.0);
            return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), intensity) * intensity * (1.0+p3);
        }

        // 7. BEAMS
        vec3 viz_beams(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float a = atan(uv.y, uv.x);
            float beams = sin(a * (10.0 + floor(p1*10.0)) + t) * sin(a*7.0+t*0.5);
            return vec3(smoothstep(0.8-p2*0.5, 1.0, beams)) * (0.1/length(uv)) * elfPalette(t + p3) * (1.0+p4);
        }

        // 8. GLITCH
        vec3 viz_glitch(vec2 uv, float t, float p1, float p2, float p3, float p4) {
             float shift = step(0.9, hash(vec2(floor(uv.y * 100.0), t)));
             uv.x += shift * 0.1 * p1;
             return vec3(step(0.5, sin(uv.x*100.0*p2))) * vec3(0.0, 1.0, 0.0) * p4;
        }

        // 9. MANDALA
        vec3 viz_mandala(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float r = length(uv);
            float a = atan(uv.y, uv.x);
            float arms = 6.0 + floor(p1 * 6.0);
            a = mod(a, 2.0*PI/arms) - PI/arms;
            uv = vec2(cos(a), sin(a)) * r;
            uv -= 0.5;
            float pat = sin(uv.x * 20.0 + t) * cos(uv.y * 20.0 - t);
            return vec3(smoothstep(0.0, 0.1, abs(pat))) * elfPalette(r + t + p3) * p4;
        }

        // 10. NEURO
        vec3 viz_neuro(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            vec2 p = uv * (3.0 + p1*3.0);
            float n = noise(p + t);
            float m = noise(p*2.0 - t);
            float val = 0.02 / abs(n - m);
            return vec3(val) * vec3(0.2, 0.5, 1.0) * p4;
        }

        // 11. RAIN
        vec3 viz_rain(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            vec2 gv = fract(uv * 20.0);
            vec2 id = floor(uv * 20.0);
            float drop = fract(t * (1.0+p1) + hash(id)*5.0);
            float val = smoothstep(0.9, 1.0, drop) * step(0.5, hash(id + vec2(1.0)));
            return vec3(0.0, 1.0, 0.5) * val * p4 * 4.0;
        }

        // 12. WAVEFORM
        vec3 viz_waveform(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float lines = 0.0;
            for(float i=0.0; i<5.0; i++){
                float y = sin(uv.x * (5.0+i) + t * (1.0+p1) + i) * 0.3 * p2;
                lines += 0.01 / abs(uv.y - y);
            }
            return vec3(lines) * elfPalette(t) * p4;
        }

        // 13. SPIRAL
        vec3 viz_spiral(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float r = length(uv);
            float a = atan(uv.y, uv.x);
            float s = sin(a * 10.0 - r * 20.0 + t * 5.0 * p1);
            return vec3(s) * elfPalette(r*2.0 - t) * p4;
        }

        // 14. CRYSTAL
        vec3 viz_crystal(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            vec2 n = floor(uv * 5.0);
            vec2 f = fract(uv * 5.0);
            float md = 1.0;
            for(int j=-1; j<=1; j++)
            for(int i=-1; i<=1; i++) {
                vec2 g = vec2(float(i),float(j));
                vec2 o = hash(n+g) * 0.5 + 0.5; // bug here? hash returns float. Fix below.
                o = vec2(hash(n+g), hash(n+g+vec2(12.3, 45.6))); // pseudo random vec2
                o = 0.5 + 0.5*sin(t + 6.28*o);
                vec2 r = g + o - f;
                float d = length(r);
                md = min(md, d);
            }
            vec3 col = elfPalette(md*2.0 + p3);
            return col * (1.0-md) * p4 * 2.0;
        }

        // 15. LATTICE
        vec3 viz_lattice(vec2 uv, float t, float p1, float p2, float p3, float p4) {
             uv *= rot(t*0.1);
             vec2 gv = fract(uv * 4.0);
             float d = length(gv-0.5);
             float circles = smoothstep(0.4, 0.41, d) - smoothstep(0.5, 0.51, d);
             return vec3(circles) * elfPalette(length(uv)*p1 + p3) * p4 * 2.0;
        }

        // 16. STARDUST (Snow replacement)
        vec3 viz_stardust(vec2 uv, float t, float p3) {
             float s = pow(noise(uv * 50.0 + t * 5.0), 30.0);
             return vec3(s) * (1.0 + p3);
        }

        vec3 getLayer(int type, vec2 uv, float time, int offset) {
            float p1, p2, p3, p4;
            if (offset == 0) { p1=u_params[0]; p2=u_params[1]; p3=u_params[2]; p4=u_params[3]; }
            else { p1=u_params[8]; p2=u_params[9]; p3=u_params[10]; p4=u_params[11]; }

            if (type == 0) return viz_fluid(uv, time, p1, p2, p3, p4);
            if (type == 1) return viz_fractal(uv, time, p1, p2, p3, p4);
            if (type == 2) return viz_entity(uv, time, p1, p2, p3, p4);
            if (type == 3) return viz_hypercube(uv, time, p1, p2, p3, p4);
            if (type == 4) return viz_tunnel(uv, time, p1, p2, p3, p4);
            if (type == 5) return viz_fire(uv, time, p1, p2, p3, p4);
            if (type == 6) return viz_beams(uv, time, p1, p2, p3, p4);
            if (type == 7) return viz_glitch(uv, time, p1, p2, p3, p4);
            if (type == 8) return viz_mandala(uv, time, p1, p2, p3, p4);
            if (type == 9) return viz_neuro(uv, time, p1, p2, p3, p4);
            if (type == 10) return viz_rain(uv, time, p1, p2, p3, p4);
            if (type == 11) return viz_waveform(uv, time, p1, p2, p3, p4);
            if (type == 12) return viz_spiral(uv, time, p1, p2, p3, p4);
            if (type == 13) return viz_crystal(uv, time, p1, p2, p3, p4);
            if (type == 14) return viz_lattice(uv, time, p1, p2, p3, p4);
            // Stardust is separate overlay
            return vec3(0.0);
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
            vec2 uv0 = uv;

            vec3 l1 = getLayer(u_layer1_type, uv, u_time, 0);
            vec3 l2 = getLayer(u_layer2_type, uv, u_time, 1);
            
            vec3 final = l1 + l2;

            // STARDUST (Controlled, Active only if Layer 15 is selected? No, separate overlay)
            // But wait, plan says "Layer 16: Stardust".
            // Let's allow Stardust to be one of the selectables.
            if (u_layer1_type == 15) final += viz_stardust(uv, u_time, u_params[2]);
            if (u_layer2_type == 15) final += viz_stardust(uv, u_time, u_params[10]);

            final *= 1.2 - length(uv0);
            gl_FragColor = vec4(final, 1.0);
        }
    </script>

    <script>
        const CONFIG = {
            handle: 'e-v-l-o-v-e.bsky.social',
            apiBase: 'https://public.api.bsky.app/xrpc',
            smoothing: 0.8
        };

        const LAYERS = [
            "FLUID", "FRACTAL", "ENTITY", "HYPERCUBE",
            "TUNNEL", "FIRE", "BEAMS", "GLITCH",
            "MANDALA", "NEURO", "RAIN", "WAVEFORM",
            "SPIRAL", "CRYSTAL", "LATTICE", "STARDUST"
        ];

        let audioCtx, analyser, dataArray;
        let smoothedBands = new Float32Array(8);
        let paramMap = new Array(16).fill(0);
        let isRunning = false;
        let startTime = Date.now();

        let activeLayer1 = 0;
        let activeLayer2 = 1;

        // ENERGY TRACKING
        let energyHistory = new Array(60).fill(0);
        let lastDrop = 0;

        // Freq Canvas
        const fcvs = document.getElementById('freqcanvas');
        const fctx = fcvs.getContext('2d');

        function initAudio() {
            navigator.mediaDevices.getDisplayMedia({ video: true, audio: true }).then(stream => {
                const AC = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AC();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 1024;
                analyser.smoothingTimeConstant = CONFIG.smoothing;

                const src = audioCtx.createMediaStreamSource(stream);
                src.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                document.getElementById('start-screen').style.opacity = 0;
                setTimeout(() => document.getElementById('start-screen').style.display = 'none', 1000);
                document.getElementById('post-card').style.opacity = 1;
                document.getElementById('post-card').style.transform = "scale(1)";

                isRunning = true;
                startTime = Date.now();
                forceReroll();
                loop();
            }).catch(e => alert("Audio Init Failed: " + e));
        }
        document.getElementById('start-btn').onclick = initAudio;

        // APP LOGIC
        function forceReroll() {
            activeLayer1 = Math.floor(Math.random() * 16);
            do { activeLayer2 = Math.floor(Math.random() * 16); } while (activeLayer1 == activeLayer2);
            for (let i = 0; i < 16; i++) paramMap[i] = Math.floor(Math.random() * 8);
            updateUI();
        }

        function cycleLayer(which) {
            if (which === 0) activeLayer1 = (activeLayer1 + 1) % 16;
            else activeLayer2 = (activeLayer2 + 1) % 16;
            updateUI();
        }

        function updateUI() {
            document.getElementById('layer-a-name').innerText = LAYERS[activeLayer1];
            document.getElementById('layer-b-name').innerText = LAYERS[activeLayer2];
        }
        window.cycleLayer = cycleLayer;
        window.forceReroll = forceReroll;

        // GL SETUP
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            // Side bar
            fcvs.width = 60;
            fcvs.height = window.innerHeight;
        }
        window.onresize = resize;
        resize();

        function createShader(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
                return null;
            }
            return s;
        }
        const prog = gl.createProgram();
        gl.attachShader(prog, createShader(gl.VERTEX_SHADER, document.getElementById('vert').text));
        gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, document.getElementById('frag').text));
        gl.linkProgram(prog);
        gl.useProgram(prog);

        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        const aPos = gl.getAttribLocation(prog, "a_position");
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

        const uTime = gl.getUniformLocation(prog, "u_time");
        const uRes = gl.getUniformLocation(prog, "u_resolution");
        const uParams = gl.getUniformLocation(prog, "u_params");
        const uL1 = gl.getUniformLocation(prog, "u_layer1_type");
        const uL2 = gl.getUniformLocation(prog, "u_layer2_type");

        function loop() {
            if (!isRunning) return requestAnimationFrame(loop);

            const t = (Date.now() - startTime) * 0.001;
            analyser.getByteFrequencyData(dataArray);

            // Audio Processing
            let bands = new Float32Array(8);
            let binSize = Math.floor(dataArray.length / 8);
            for (let i = 0; i < 8; i++) {
                let sum = 0;
                for (let j = 0; j < binSize; j++) sum += dataArray[i * binSize + j];
                bands[i] = (sum / binSize) / 255.0;
            }

            // Draw Frequency Sidebar
            fctx.clearRect(0, 0, fcvs.width, fcvs.height);
            let barH = fcvs.height / 8;
            for (let i = 0; i < 8; i++) {
                let hue = i * 40;
                let val = bands[7 - i]; // Highs at top
                fctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                fctx.fillRect(0, i * barH, val * 60, barH - 2);
            }

            // Drop Detection
            let energy = bands.reduce((a, b) => a + b) / 8;
            energyHistory.shift();
            energyHistory.push(energy);
            let avg = energyHistory.reduce((a, b) => a + b) / 60;

            if (Date.now() - lastDrop > 5000) {
                if (energy > avg * 1.5 && energy > 0.3) {
                    forceReroll();
                    lastDrop = Date.now();
                }
            }

            // Smooth
            let finalParams = new Float32Array(16);
            for (let i = 0; i < 8; i++)
                smoothedBands[i] += (bands[i] - smoothedBands[i]) * 0.1;

            for (let i = 0; i < 16; i++)
                finalParams[i] = smoothedBands[paramMap[i]];

            gl.uniform1f(uTime, t);
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1fv(uParams, finalParams);
            gl.uniform1i(uL1, activeLayer1);
            gl.uniform1i(uL2, activeLayer2);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(loop);
        }

        // FEED
        async function fetchFeed() {
            try {
                const didRes = await fetch(`${CONFIG.apiBase}/com.atproto.identity.resolveHandle?handle=${CONFIG.handle}`);
                const didData = await didRes.json();
                const feedRes = await fetch(`${CONFIG.apiBase}/app.bsky.feed.getAuthorFeed?actor=${didData.did}&limit=1`);
                const feedData = await feedRes.json();

                if (feedData.feed && feedData.feed.length > 0) {
                    const post = feedData.feed[0].post;
                    const txt = document.getElementById('post-text');
                    if (txt.innerText !== post.record.text) {
                        txt.innerText = post.record.text;
                        const d = new Date(post.record.createdAt);
                        document.getElementById('post-date').innerText = d.toLocaleTimeString() + " // LINK ESTABLISHED";
                    }
                    if (post.embed?.images?.[0]) {
                        document.getElementById('post-image').src = post.embed.images[0].fullsize;
                        document.getElementById('post-image').style.display = 'block';
                    }
                }
            } catch (e) { }
        }
        setInterval(fetchFeed, 10000);
        fetchFeed();

    </script>
</body>

</html>