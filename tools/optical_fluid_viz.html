<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üëÅÔ∏è HYPER-COLOR ENGINE v4</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&display=swap');

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Rajdhani', sans-serif;
            color: #fff;
        }

        canvas#glcanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        canvas#freqcanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 80px;
            height: 100%;
            z-index: 20;
            background: rgba(0, 0, 0, 0.5);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 80px;
            width: calc(100% - 80px);
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #start-screen {
            background: rgba(0, 0, 0, 0.95);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            transition: opacity 1s ease;
        }

        h1 {
            font-size: 6rem;
            letter-spacing: 20px;
            margin: 0 0 20px 0;
            text-align: center;
            background: linear-gradient(90deg, #f0f, #0ff, #fff, #ff0, #f0f);
            background-size: 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbow 3s linear infinite;
        }

        @keyframes rainbow {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 100% 50%;
            }
        }

        button.start-btn {
            margin-top: 50px;
            padding: 20px 80px;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            font-size: 2rem;
            letter-spacing: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button.start-btn:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 40px #fff;
            transform: scale(1.1);
        }

        /* CHECKBOX BAR */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 100px;
            right: 20px;
            z-index: 50;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            pointer-events: auto;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }

        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
            color: #888;
            cursor: pointer;
            user-select: none;
            padding: 5px 10px;
            border: 1px solid #333;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .layer-toggle.active {
            color: #fff;
            border-color: #0ff;
            background: rgba(0, 255, 255, 0.1);
            text-shadow: 0 0 5px #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }

        .layer-toggle:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .sys-btn {
            padding: 5px 15px;
            background: transparent;
            border: 1px solid #f0f;
            color: #f0f;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            cursor: pointer;
            margin-left: 20px;
            text-transform: uppercase;
        }

        .sys-btn:hover {
            background: #f0f;
            color: #000;
            box-shadow: 0 0 15px #f0f;
        }

        /* FEED */
        #post-card {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 40px;
            border-radius: 12px;
            width: 80%;
            max-width: 800px;
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        .handle {
            color: #0ff;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 2px;
        }

        #post-text {
            font-size: 1.8rem;
            line-height: 1.4;
            font-weight: 500;
        }

        #post-image {
            width: 100%;
            margin-top: 20px;
            display: none;
        }
    </style>
</head>

<body>

    <canvas id="glcanvas"></canvas>
    <canvas id="freqcanvas"></canvas>

    <div id="start-screen">
        <h1>HYPER-COLOR</h1>
        <p style="letter-spacing: 5px; color: #888;">VISUAL ENGINE v4.0</p>
        <button id="start-btn" class="start-btn">IGNITE</button>
    </div>

    <div id="ui-layer">
        <div id="post-card">
            <span class="handle">@e-v-l-o-v-e.bsky.social</span>
            <div id="post-text">Initializing 48-Band Analysis...</div>
            <img id="post-image" />
            <div id="post-date" style="text-align: right; margin-top: 15px; color: #888;">SYSTEM READY</div>
        </div>
    </div>

    <div id="controls">
        <!-- Generated by JS -->
    </div>

    <!-- SHADERS -->
    <script id="vert" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="frag" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision highp float;
        #endif

        uniform float u_time;
        uniform vec2 u_resolution;
        uniform float u_params[16];
        uniform float u_active[16]; // 0.0 or 1.0 for each layer
        uniform float u_active_count; // Number of active layers for normalization

        #define PI 3.14159265359

        // --- UTILS ---
        mat2 rot(float a) {
            float s = sin(a), c = cos(a);
            return mat2(c, -s, s, c);
        }

        float hash(vec2 p) {
            vec3 p3  = fract(vec3(p.xyx) * 0.1031);
            p3 += dot(p3, p3.yzx + 33.33);
            return fract((p3.x + p3.y) * p3.z);
        }

        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            for (int i=0; i<5; i++) {
                v += a * noise(p);
                p *= 2.0;
                a *= 0.5;
            }
            return v;
        }

        // VIBRANT HSL PALETTE
        vec3 hsl2rgb(vec3 c) {
            vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
            return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
        }

        vec3 hyperPalette(float t) {
            // High saturation, shifting hue
            return hsl2rgb(vec3(fract(t), 0.9, 0.6));
        }

        vec3 neonPalette(float t) {
            return 0.5 + 0.5*cos(6.28318*(vec3(1.0,1.0,1.0)*t+vec3(0.0,0.33,0.67)));
        }

        // --- VISUAL LAYERS ---
        // Need wrapper to inject params cleanly
        // Using global p1...p4 for simplicity inside loop could work, 
        // but passing them is cleaner.

        // Shared params for simplicity in this loop structure
        // Map: 
        // Band 0 -> P1 (Structure/Scale)
        // Band 1 -> P2 (Complexity/Detail)
        // Band 2 -> P3 (Color Shift)
        // Band 3 -> P4 (Intensity/Speed)

        // 1. FLUID
        vec3 viz_fluid(vec2 uv, float t, float p1, float p2, float p3, float p4) {
             vec2 p = uv * (3.0 + p1); 
             vec2 q = vec2(fbm(p), fbm(p + vec2(5.2, 1.3)));
             vec2 r = vec2(fbm(p + 4.0*q + vec2(1.7, 9.2) + 0.15*t), fbm(p + 4.0*q + vec2(8.3, 2.8) - 0.12*t));
             float f = fbm(p + 4.0*r);
             return hyperPalette(f * 2.0 + t * 0.1 + p3) * f * f * (2.0 + p4*3.0);
        }

        // 2. FRACTAL
        vec3 viz_fractal(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            uv *= 1.5 - p1*0.5;
            vec2 z = uv;
            float scale = 1.5 + p2 * 0.5;
            float angle = t * 0.1 + p3;
            float d = 100.0;
            for(int i=0; i<4; i++) {
                z = abs(z) - 0.5; z *= rot(angle); z *= scale;
                d = min(d, length(z) / pow(scale, float(i)));
            }
            return vec3(0.03 / max(d, 0.001) * (0.8 + p4)) * neonPalette(length(uv) + t);
        }

        // 3. ENTITY
        vec3 viz_entity(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            uv.x = abs(uv.x);
            vec2 eyeUV = uv - vec2(0.4, 0.2 * sin(t));
            float r = length(eyeUV);
            float f = sin(atan(eyeUV.y, eyeUV.x) * 10.0 + t) * cos(r * 20.0 - t*2.0);
            float pupil = smoothstep(0.1 + p1*0.2, 0.05, r);
            float iris = smoothstep(0.4, 0.3, r) - pupil;
            return (vec3(f * iris) * hyperPalette(p3 + r)) + vec3(pupil);
        }

        // 4. HYPERCUBE
        vec3 viz_hypercube(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            uv *= rot(t * 0.2);
            vec2 gv = fract(uv * (2.0 + p1*2.0)) - 0.5;
            vec2 id = floor(uv * (2.0 + p1*2.0));
            float d = length(max(abs(gv) - 0.3, 0.0));
            float mask = smoothstep(0.04, 0.01, abs(d));
            return (vec3(mask) + vec3(0.1/length(gv)*p3)) * neonPalette(id.x + id.y + t*0.5 + p2) * (0.5+p4);
        }

        // 5. TUNNEL
        vec3 viz_tunnel(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float r = length(uv);
            float a = atan(uv.y, uv.x) + 1.0/(r+0.01)*sin(t*0.5);
            float u = 0.5/r + t * (0.5 + p1);
            float v = a/PI * (2.0 + floor(p2*5.0));
            float tex = step(0.5, fract(u)) * step(0.5, fract(v)) + step(0.9, fract(u))*2.0;
            return vec3(tex) * (r*r*3.0) * hyperPalette(u + p3) * (0.5+p4);
        }

        // 6. FIRE
        vec3 viz_fire(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float n = fbm(uv * 3.0 + vec2(0.0, -t*(0.8+p1)));
            float intensity = pow(n * (1.0 - (uv.y+0.5)) * 2.5, 2.0);
            return mix(vec3(1.0, 0.1, 0.0), vec3(1.0, 1.0, 0.5), intensity) * intensity * (1.5+p3);
        }

        // 7. BEAMS
        vec3 viz_beams(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float a = atan(uv.y, uv.x);
            float beams = sin(a * (12.0 + floor(p1*10.0)) + t) * sin(a*8.0+t*0.5);
            return vec3(smoothstep(0.8-p2*0.5, 1.0, beams)) * (0.15/length(uv)) * neonPalette(t + p3) * (1.0+p4);
        }

        // 8. GLITCH
        vec3 viz_glitch(vec2 uv, float t, float p1, float p2, float p3, float p4) {
             float shift = step(0.9, hash(vec2(floor(uv.y * 100.0), t)));
             uv.x += shift * 0.1 * p1;
             return vec3(step(0.5, sin(uv.x*100.0*p2))) * vec3(0.0, 1.0, 0.2) * p4;
        }

        // 9. MANDALA
        vec3 viz_mandala(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float r = length(uv);
            float a = atan(uv.y, uv.x);
            float arms = 6.0 + floor(p1 * 6.0);
            a = mod(a, 2.0*PI/arms) - PI/arms;
            uv = vec2(cos(a), sin(a)) * r;
            uv -= 0.5;
            float pat = sin(uv.x * 20.0 + t) * cos(uv.y * 20.0 - t);
            return vec3(smoothstep(0.0, 0.15, abs(pat))) * hyperPalette(r + t + p3) * (0.3 + p4 * 2.0);
        }

        // 10. NEURO
        vec3 viz_neuro(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            vec2 p = uv * (3.0 + p1*3.0);
            float n = noise(p + t);
            float m = noise(p*2.0 - t);
            float val = 0.03 / abs(n - m);
            return vec3(val) * vec3(0.2, 0.6, 1.0) * (0.5 + p4 * 2.5);
        }

        // 11. RAIN
        vec3 viz_rain(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            vec2 gv = fract(uv * 30.0);
            vec2 id = floor(uv * 30.0);
            float drop = fract(t * (1.0+p1) + hash(id)*5.0);
            float val = smoothstep(0.9, 1.0, drop) * step(0.5, hash(id + vec2(1.0)));
            return vec3(0.0, 1.0, 0.5) * val * (1.0 + p4 * 4.0);
        }

        // 12. WAVEFORM
        vec3 viz_waveform(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float lines = 0.0;
            for(float i=0.0; i<6.0; i++){
                float y = sin(uv.x * (4.0+i) + t * (1.5+p1) + i) * 0.35 * p2;
                lines += 0.015 / abs(uv.y - y);
            }
            return vec3(lines) * hyperPalette(t) * (0.5 + p4 * 2.0);
        }

        // 13. SPIRAL
        vec3 viz_spiral(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float r = length(uv);
            float a = atan(uv.y, uv.x);
            float s = sin(a * 10.0 - r * 20.0 + t * 5.0 * p1);
            return vec3(smoothstep(0.0, 0.5, s)) * neonPalette(r*2.0 - t) * (0.5 + p4 * 2.0);
        }

        // 14. CRYSTAL
        vec3 viz_crystal(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            vec2 n = floor(uv * 5.0);
            vec2 f = fract(uv * 5.0);
            float md = 1.0;
            for(int j=-1; j<=1; j++)
            for(int i=-1; i<=1; i++) {
                vec2 g = vec2(float(i),float(j));
                vec2 o = vec2(hash(n+g), hash(n+g+vec2(12.3, 45.6)));
                o = 0.5 + 0.5*sin(t + 6.28*o);
                float d = length(g + o - f);
                md = min(md, d);
            }
            vec3 col = hyperPalette(md*3.0 + p3);
            return col * pow(1.0-md, 2.0) * (0.3 + p4 * 3.0);
        }

        // 15. LATTICE
        vec3 viz_lattice(vec2 uv, float t, float p1, float p2, float p3, float p4) {
             uv *= rot(t*0.1);
             vec2 gv = fract(uv * 4.0);
             float d = length(gv-0.5);
             float circles = smoothstep(0.4, 0.41, d) - smoothstep(0.5, 0.51, d);
             return vec3(circles) * neonPalette(length(uv)*p1 + p3) * (0.5 + p4 * 2.0);
        }

         // 16. STARDUST
        vec3 viz_stardust(vec2 uv, float t, float p3) {
             float s = pow(noise(uv * 60.0 + t * 4.0), 40.0);
             return vec3(s) * (2.0 + p3);
        }

        // TONE MAPPING (ACES)
        vec3 aces(vec3 x) {
            float a = 2.51;
            float b = 0.03;
            float c = 2.43;
            float d = 0.59;
            float e = 0.14;
            return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
            
            // To improve performance, we only calculate what is active
            // However, with WebGL 1/ES2, dynamic branching can be slow or compiled out.
            // But we need to support any combination.
            
            vec3 accum = vec3(0.0);
            
            // Map Params consistently
            float p1 = u_params[0]; // Structure
            float p2 = u_params[1]; // Detail
            float p3 = u_params[2]; // Color
            float p4 = u_params[3]; // Intensity

            if(u_active[0] > 0.5) accum += viz_fluid(uv, u_time, p1, p2, p3, p4);
            if(u_active[1] > 0.5) accum += viz_fractal(uv, u_time, p1, p2, p3, p4);
            if(u_active[2] > 0.5) accum += viz_entity(uv, u_time, p1, p2, p3, p4);
            if(u_active[3] > 0.5) accum += viz_hypercube(uv, u_time, p1, p2, p3, p4);
            if(u_active[4] > 0.5) accum += viz_tunnel(uv, u_time, p1, p2, p3, p4);
            if(u_active[5] > 0.5) accum += viz_fire(uv, u_time, p1, p2, p3, p4);
            if(u_active[6] > 0.5) accum += viz_beams(uv, u_time, p1, p2, p3, p4);
            if(u_active[7] > 0.5) accum += viz_glitch(uv, u_time, p1, p2, p3, p4);
            if(u_active[8] > 0.5) accum += viz_mandala(uv, u_time, p1, p2, p3, p4);
            if(u_active[9] > 0.5) accum += viz_neuro(uv, u_time, p1, p2, p3, p4);
            if(u_active[10] > 0.5) accum += viz_rain(uv, u_time, p1, p2, p3, p4);
            if(u_active[11] > 0.5) accum += viz_waveform(uv, u_time, p1, p2, p3, p4);
            if(u_active[12] > 0.5) accum += viz_spiral(uv, u_time, p1, p2, p3, p4);
            if(u_active[13] > 0.5) accum += viz_crystal(uv, u_time, p1, p2, p3, p4);
            if(u_active[14] > 0.5) accum += viz_lattice(uv, u_time, p1, p2, p3, p4);
            if(u_active[15] > 0.5) accum += viz_stardust(uv, u_time, p3);

            // Normalization & Post FX
            // We want it bright, not washed out.
            // Soft normalization based on active count
            if (u_active_count > 1.0) {
                 accum /= sqrt(u_active_count);
            }

            // Vignette
            accum *= 1.2 - length(uv);

            // Tone Map & Gamma
            accum = aces(accum);
            accum = pow(accum, vec3(1.0/2.2)); // Gamma correction

            gl_FragColor = vec4(accum, 1.0);
        }
    </script>

    <script>
        const CONFIG = {
            handle: 'e-v-l-o-v-e.bsky.social',
            apiBase: 'https://public.api.bsky.app/xrpc',
            smoothing: 0.85
        };

        const LAYERS = [
            "FLUID", "FRACTAL", "ENTITY", "HYPERCUBE",
            "TUNNEL", "FIRE", "BEAMS", "GLITCH",
            "MANDALA", "NEURO", "RAIN", "WAVEFORM",
            "SPIRAL", "CRYSTAL", "LATTICE", "STARDUST"
        ];

        // State
        let activeLayers = new Array(16).fill(false);
        // Default Active
        activeLayers[0] = true;
        activeLayers[15] = true;

        // Audio Mapping State
        // 4 params x [startBand, count]
        // Default: 0-12, 12-12, 24-12, 36-12
        let paramMap = [
            { s: 0, c: 12 },   // P1
            { s: 12, c: 12 },  // P2
            { s: 24, c: 12 },  // P3
            { s: 36, c: 12 }   // P4
        ];

        let autoReroll = false;
        let lastAutoTime = 0;
        let avgEnergy = 0;

        let audioCtx, analyser, dataArray;
        // 48 Bands
        let smoothedBands = new Float32Array(48);

        let isRunning = false;
        let startTime = Date.now();

        // Freq Canvas
        const fcvs = document.getElementById('freqcanvas');
        const fctx = fcvs.getContext('2d');

        // UI Builder
        const controls = document.getElementById('controls');
        LAYERS.forEach((name, i) => {
            const btn = document.createElement('div');
            btn.className = 'layer-toggle' + (activeLayers[i] ? ' active' : '');
            btn.innerText = name;
            btn.onclick = () => toggleLayer(i, btn);
            controls.appendChild(btn);
        });

        // ROW 2: System Controls
        const sysRow = document.createElement('div');
        sysRow.style.width = "100%";
        sysRow.style.display = "flex";
        sysRow.style.justifyContent = "center";
        sysRow.style.marginTop = "10px";
        sysRow.style.gap = "15px";
        controls.appendChild(sysRow);

        const randBtn = document.createElement('button');
        randBtn.className = 'sys-btn';
        randBtn.innerText = 'REROLL CHAOS';
        randBtn.onclick = () => forceReroll(true);
        sysRow.appendChild(randBtn);

        const autoBtn = document.createElement('button');
        autoBtn.className = 'sys-btn';
        autoBtn.innerText = 'AUTO: OFF';
        autoBtn.onclick = () => {
            autoReroll = !autoReroll;
            autoBtn.innerText = autoReroll ? 'AUTO: ON' : 'AUTO: OFF';
            autoBtn.style.background = autoReroll ? '#f0f' : 'transparent';
            autoBtn.style.color = autoReroll ? '#000' : '#f0f';
        };
        sysRow.appendChild(autoBtn);


        function toggleLayer(idx, btn) {
            activeLayers[idx] = !activeLayers[idx];
            btn.className = 'layer-toggle' + (activeLayers[idx] ? ' active' : '');
        }

        function forceReroll(randomizeLayers) {
            // 1. Randomize Active Layers (if requested or auto)
            if (randomizeLayers) {
                activeLayers.fill(false);
                let count = 2 + Math.floor(Math.random() * 4); // 2 to 5 layers
                for (let k = 0; k < count; k++) {
                    activeLayers[Math.floor(Math.random() * 16)] = true;
                }
                // Update UI
                const btns = document.querySelectorAll('.layer-toggle');
                btns.forEach((b, i) => {
                    b.className = 'layer-toggle' + (activeLayers[i] ? ' active' : '');
                });
            }

            // 2. Randomize Audio Mappings (ALWAYS)
            // Pick a random chunk of spectrum for each param
            for (let i = 0; i < 4; i++) {
                paramMap[i].s = Math.floor(Math.random() * 36); // Start anywhere 0-36
                paramMap[i].c = 3 + Math.floor(Math.random() * 12); // Width 3-15 bands
            }
        }


        function initAudio() {
            navigator.mediaDevices.getDisplayMedia({ video: true, audio: true }).then(stream => {
                const AC = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AC();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048; // High res for 48 bands
                // Increased smoothing for smoother visuals but keep responsiveness for drops
                analyser.smoothingTimeConstant = CONFIG.smoothing;

                const src = audioCtx.createMediaStreamSource(stream);
                src.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                document.getElementById('start-screen').style.opacity = 0;
                setTimeout(() => document.getElementById('start-screen').style.display = 'none', 1000);
                document.getElementById('post-card').style.opacity = 1;

                isRunning = true;
                startTime = Date.now();
                loop();
            }).catch(e => alert("Audio Init Failed: " + e));
        }
        document.getElementById('start-btn').onclick = initAudio;

        // GL SETUP
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            fcvs.width = 80;
            fcvs.height = window.innerHeight;
        }
        window.onresize = resize;
        resize();

        function createShader(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
                return null;
            }
            return s;
        }
        const prog = gl.createProgram();
        gl.attachShader(prog, createShader(gl.VERTEX_SHADER, document.getElementById('vert').text));
        gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, document.getElementById('frag').text));
        gl.linkProgram(prog);
        gl.useProgram(prog);

        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        const aPos = gl.getAttribLocation(prog, "a_position");
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

        const uTime = gl.getUniformLocation(prog, "u_time");
        const uRes = gl.getUniformLocation(prog, "u_resolution");
        const uParams = gl.getUniformLocation(prog, "u_params");
        const uActive = gl.getUniformLocation(prog, "u_active");
        const uCount = gl.getUniformLocation(prog, "u_active_count");

        function loop() {
            if (!isRunning) return requestAnimationFrame(loop);

            const now = Date.now();
            const t = (now - startTime) * 0.001;
            analyser.getByteFrequencyData(dataArray);

            // 48 Band Analysis
            let binSize = Math.floor(dataArray.length / 60);
            let currentTotalEnergy = 0;

            for (let i = 0; i < 48; i++) {
                let sum = 0;
                let start = i * binSize;
                for (let j = 0; j < binSize; j++) sum += dataArray[start + j];
                let val = (sum / binSize) / 255.0;

                // Attack/Decay
                if (val > smoothedBands[i]) smoothedBands[i] = val;
                else smoothedBands[i] += (val - smoothedBands[i]) * 0.1;

                currentTotalEnergy += val;
            }
            currentTotalEnergy /= 48.0;

            // AUTO-REROLL LOGIC
            // Simple beat detection: average over time vs immediate
            avgEnergy = avgEnergy * 0.99 + currentTotalEnergy * 0.01;

            // Threshold for drop: 1.5x average energy, min cooldown 4s
            if (autoReroll && (now - lastAutoTime > 4000) && (currentTotalEnergy > avgEnergy * 1.5) && (currentTotalEnergy > 0.1)) {
                forceReroll(true);
                lastAutoTime = now;
                // Visual flash on sidebar
                fctx.fillStyle = "white";
                fctx.fillRect(0, 0, 80, window.innerHeight);
            }

            // Draw Frequency Sidebar (48 bars)
            fctx.clearRect(0, 0, fcvs.width, fcvs.height);
            let barH = fcvs.height / 48;
            for (let i = 0; i < 48; i++) {
                let hue = i * 6;
                let val = smoothedBands[47 - i];
                fctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                let w = val * 80;
                fctx.fillRect(0, i * barH, w, barH - 1);
            }

            // Map 48 bands to 4 Shader Params DYNAMICALLY
            let params = new Float32Array(4);
            for (let p = 0; p < 4; p++) {
                let map = paramMap[p];
                let sum = 0;
                let count = 0;
                for (let k = 0; k < map.c; k++) {
                    let idx = map.s + k;
                    if (idx < 48) {
                        sum += smoothedBands[idx];
                        count++;
                    }
                }
                params[p] = count > 0 ? (sum / count) : 0;
            }

            // Prepare active array
            let activeFloats = new Float32Array(16);
            let activeCount = 0;
            for (let i = 0; i < 16; i++) {
                if (activeLayers[i]) {
                    activeFloats[i] = 1.0;
                    activeCount++;
                } else {
                    activeFloats[i] = 0.0;
                }
            }

            gl.uniform1f(uTime, t);
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1fv(uParams, params);
            gl.uniform1fv(uActive, activeFloats);
            gl.uniform1f(uCount, activeCount);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(loop);
        }

        // FEED
        async function fetchFeed() {
            try {
                const didRes = await fetch(`${CONFIG.apiBase}/com.atproto.identity.resolveHandle?handle=${CONFIG.handle}`);
                const didData = await didRes.json();
                const feedRes = await fetch(`${CONFIG.apiBase}/app.bsky.feed.getAuthorFeed?actor=${didData.did}&limit=1`);
                const feedData = await feedRes.json();

                if (feedData.feed && feedData.feed.length > 0) {
                    const post = feedData.feed[0].post;
                    const txt = document.getElementById('post-text');
                    if (txt.innerText !== post.record.text) {
                        txt.innerText = post.record.text;
                        const d = new Date(post.record.createdAt);
                        document.getElementById('post-date').innerText = d.toLocaleTimeString() + " // LINK ESTABLISHED";
                    }
                    if (post.embed?.images?.[0]) {
                        document.getElementById('post-image').src = post.embed.images[0].fullsize;
                        document.getElementById('post-image').style.display = 'block';
                    }
                }
            } catch (e) { }
        }
        setInterval(fetchFeed, 10000);
        fetchFeed();

    </script>
</body>

</html>