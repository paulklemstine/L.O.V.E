<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üëÅÔ∏è MACHINE ELF ENGINE v2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;500;700&display=swap');

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Rajdhani', sans-serif;
            color: #fff;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #start-screen {
            background: rgba(0, 0, 0, 0.95);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            transition: opacity 1s ease;
        }

        h1 {
            font-size: 6rem;
            letter-spacing: 20px;
            margin: 0 0 20px 0;
            text-align: center;
            background: linear-gradient(90deg, #f0f, #0ff, #fff, #ff0, #f0f);
            background-size: 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbow 3s linear infinite;
        }

        @keyframes rainbow {
            0% {
                background-position: 0% 50%;
            }

            100% {
                background-position: 100% 50%;
            }
        }

        button {
            margin-top: 50px;
            padding: 20px 80px;
            background: transparent;
            border: 2px solid #fff;
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            font-size: 2rem;
            letter-spacing: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #fff;
            color: #000;
            box-shadow: 0 0 40px #fff;
            transform: scale(1.1);
        }

        /* POST CARD */
        #post-card {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 40px;
            border-radius: 12px;
            width: 80%;
            max-width: 800px;
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        .handle {
            color: #0ff;
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: 2px;
            display: block;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #0ff;
        }

        #post-text {
            font-size: 1.8rem;
            line-height: 1.4;
            font-weight: 500;
            text-shadow: 0 2px 5px #000;
        }

        #post-image {
            width: 100%;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        /* STATUS */
        #layer-status {
            position: absolute;
            bottom: 40px;
            left: 40px;
            font-size: 1.2rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 4px;
            z-index: 20;
            color: rgba(255, 255, 255, 0.7);
        }
    </style>
</head>

<body>

    <canvas id="glcanvas"></canvas>

    <div id="start-screen">
        <h1>MACHINE ELF</h1>
        <p style="letter-spacing: 5px; color: #888;">HYPER-DIMENSIONAL VISUALIZER v2.0</p>
        <button id="start-btn">ENTER VOID</button>
    </div>

    <div id="ui-layer">
        <div id="post-card">
            <span class="handle">@e-v-l-o-v-e.bsky.social</span>
            <div id="post-text">Attuning to hyperspace frequencies...</div>
            <img id="post-image" />
            <div id="post-date" style="text-align: right; margin-top: 15px; color: #888; font-size: 0.9rem;">SYSTEM
                READY</div>
        </div>
    </div>

    <div id="layer-status">Waiting for Signal...</div>

    <!-- SHADERS -->
    <script id="vert" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="frag" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision highp float;
        #endif

        uniform float u_time;
        uniform vec2 u_resolution;
        uniform float u_params[16];
        uniform int u_layer1_type;
        uniform int u_layer2_type;

        #define PI 3.14159265359

        // --- UTILS ---
        mat2 rot(float a) {
            float s = sin(a), c = cos(a);
            return mat2(c, -s, s, c);
        }

        // Improved Hash
        float hash(vec2 p) {
            vec3 p3  = fract(vec3(p.xyx) * 0.1031);
            p3 += dot(p3, p3.yzx + 33.33);
            return fract((p3.x + p3.y) * p3.z);
        }

        float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        float fbm(vec2 p) {
            float v = 0.0;
            float a = 0.5;
            for (int i=0; i<5; i++) {
                v += a * noise(p);
                p *= 2.0;
                a *= 0.5;
            }
            return v;
        }

        // MACHINE ELF PALETTE
        // Cosine based mix
        vec3 elfPalette(float t) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 1.0, 1.0);
            vec3 d = vec3(0.263, 0.416, 0.557); 
            // Phase shift for neon
            return a + b * cos(6.28318 * (c * t + d + vec3(0.0, 0.1, 0.2)));
        }

        // --- VISUAL LIBRARY ---

        // 1. FLUID (Enhanced - Anchored)
        vec3 viz_fluid(vec2 uv, float t, float p1, float p2, float p3, float p4) {
             vec2 p = uv * (3.0 + p1); 
             // Fix Drift: Domain warping uses relative offsets, not global translation
             vec2 q = vec2(fbm(p + vec2(0.0, 0.0)), fbm(p + vec2(5.2, 1.3)));
             vec2 r = vec2(fbm(p + 4.0*q + vec2(1.7, 9.2) + 0.15*t*(0.1+p2)), 
                           fbm(p + 4.0*q + vec2(8.3, 2.8) - 0.12*t));
             float f = fbm(p + 4.0*r);
             
             // Color
             float hue = f * 3.0 + t * 0.1 + p3;
             vec3 col = elfPalette(hue);
             return col * f * f * (1.5 + p4*2.0);
        }

        // 2. KIFS FRACTAL (Geometric)
        vec3 viz_fractal(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            uv *= 1.5 - p1*0.5;
            vec3 col = vec3(0.0);
            vec2 z = uv;
            
            float scale = 1.5 + p2 * 0.5;
            float angle = t * 0.1 + p3;
            
            float d = 100.0;
            for(int i=0; i<4; i++) {
                z = abs(z) - 0.5; // Fold
                z *= rot(angle);
                z *= scale;
                d = min(d, length(z) / pow(scale, float(i)));
            }
            
            // Glow
            float glow = 0.02 / max(d, 0.001);
            glow *= (0.5 + p4);
            return vec3(glow) * elfPalette(length(uv) + t);
        }

        // 3. ENTITY (Symmetry Face)
        vec3 viz_entity(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            // Mirror X
            uv.x = abs(uv.x);
            // Translate to form "eyes"
            vec2 eyeUV = uv - vec2(0.4, 0.2 * sin(t));
            
            float r = length(eyeUV);
            float a = atan(eyeUV.y, eyeUV.x);
            
            // Iris pattern
            float f = sin(a * 10.0 + t) * cos(r * 20.0 - t*2.0);
            float pupil = smoothstep(0.1 + p1*0.2, 0.05, r);
            float iris = smoothstep(0.4, 0.3, r) - pupil;
            
            vec3 col = vec3(f * iris) * elfPalette(p3 + r);
            col += vec3(pupil); // Black pupil logic reversed here (white pupil for glowing entity)
            
            // Background waves
            float wave = sin(uv.y * 10.0 + uv.x * 10.0 + t);
            col += vec3(wave * 0.1 * p4);
            
            return col;
        }

        // 4. HYPERCUBE (Projected)
        vec3 viz_hypercube(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            // Pseudo-3D wireframe
            // Simply drawing lines
            vec3 col = vec3(0.0);
            
            // Rotate space
            uv *= rot(t * 0.2);
            
            // Grid of boxes
            vec2 gv = fract(uv * (2.0 + p1*2.0)) - 0.5;
            vec2 id = floor(uv * (2.0 + p1*2.0));
            
            float d = length(max(abs(gv) - 0.3, 0.0)); // Box SDF
            
            // Rotation inside box
            // Only draw edges
            float w = 0.02;
            float mask = smoothstep(w + 0.01, w, abs(d)); // Solid outline
            
            // Inner glowing core
            float core = 0.05 / length(gv);
            
            vec3 boxCol = elfPalette(id.x + id.y + t*0.5 + p2);
            return (vec3(mask) + vec3(core * p3)) * boxCol * (0.5 + p4);
        }

        // 5. TUNNEL (V2)
        vec3 viz_tunnel(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float r = length(uv);
            float a = atan(uv.y, uv.x);
            
            // Twist
            a += 1.0 / (r + 0.01) * sin(t*0.5);
            
            // Texture
            float u = 0.5/r + t * (0.5 + p1); // Speed
            float v = a/PI * (2.0 + floor(p2 * 5.0)); // Segments
            
            float tex = step(0.5, fract(u)) * step(0.5, fract(v));
            tex += step(0.9, fract(u)) * 2.0; // Rings
            
            vec3 col = vec3(tex) * (r * r * 2.0); // Fade center
            return col * elfPalette(u + p3) * (0.5 + p4);
        }

        // 6. FIRE (Fixed Drift)
        vec3 viz_fire(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            // Anchor Y movement
            vec2 offset = vec2(0.0, -t * (0.5 + p1));
            // Noise sampling
            float n = fbm(uv * 3.0 + offset);
            
            // Gradient: Bottom=Hot, Top=Cool
            // Map UV.y to flame height properly
            // Center is 0, so -1 to 1.
            float yGradient = 1.0 - (uv.y + 0.5); // Bottom is 1.0
            
            float intensity = n * yGradient * 2.0;
            intensity = pow(intensity, 2.0); // Contrast
            
            vec3 col = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), intensity);
            return col * intensity * (1.0 + p3);
        }
        
        // 7. BEAMS
        vec3 viz_beams(vec2 uv, float t, float p1, float p2, float p3, float p4) {
            float a = atan(uv.y, uv.x);
            float r = length(uv);
            float beams = sin(a * (10.0 + floor(p1*10.0)) + t) * sin(a*(7.0)+t*0.5);
            beams = smoothstep(0.8 - p2*0.5, 1.0, beams);
            return vec3(beams) * (0.1/r) * elfPalette(t + p3) * (1.0 + p4);
        }

        // 8. GLITCH
        vec3 viz_glitch(vec2 uv, float t, float p1, float p2, float p3, float p4) {
             // Displace
             float shift = step(0.9, hash(vec2(floor(uv.y * 100.0), t)));
             uv.x += shift * 0.1 * p1;
             
             // Bar code
             float bar = step(0.5, sin(uv.x * 100.0 * p2));
             vec3 col = vec3(bar) * vec3(0.0, 1.0, 0.0);
             return col * p4;
        }

        vec3 getLayer(int type, vec2 uv, float time, int offset) {
            float p1, p2, p3, p4;
            // Map parameters
            if (offset == 0) {
                 p1 = u_params[0]; p2 = u_params[1]; p3 = u_params[2]; p4 = u_params[3];
            } else {
                 p1 = u_params[8]; p2 = u_params[9]; p3 = u_params[10]; p4 = u_params[11];
            }

            if (type == 0) return viz_fluid(uv, time, p1, p2, p3, p4);
            if (type == 1) return viz_fractal(uv, time, p1, p2, p3, p4);
            if (type == 2) return viz_entity(uv, time, p1, p2, p3, p4);
            if (type == 3) return viz_hypercube(uv, time, p1, p2, p3, p4);
            if (type == 4) return viz_tunnel(uv, time, p1, p2, p3, p4);
            if (type == 5) return viz_fire(uv, time, p1, p2, p3, p4);
            if (type == 6) return viz_beams(uv, time, p1, p2, p3, p4);
            if (type == 7) return viz_glitch(uv, time, p1, p2, p3, p4);
            return vec3(0.0);
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
            vec2 uv0 = uv;

            vec3 l1 = getLayer(u_layer1_type, uv, u_time, 0);
            vec3 l2 = getLayer(u_layer2_type, uv, u_time, 1);
            
            vec3 final = l1 + l2;
            
            // Global Sparkles
            float s = pow(noise(uv * 50.0 + u_time * 5.0), 30.0);
            final += vec3(s) * 2.0;

            final *= 1.2 - length(uv0);

            gl_FragColor = vec4(final, 1.0);
        }
    </script>

    <script>
        const CONFIG = {
            handle: 'e-v-l-o-v-e.bsky.social',
            apiBase: 'https://public.api.bsky.app/xrpc',
            smoothing: 0.8
        };

        const LAYERS = [
            "FLUID", "FRACTAL", "ENTITY", "HYPERCUBE",
            "TUNNEL", "FIRE", "BEAMS", "GLITCH"
        ];

        let audioCtx, analyser, dataArray;
        let smoothedBands = new Float32Array(8);
        let paramMap = new Array(16).fill(0);
        let isRunning = false;
        let startTime = Date.now();

        let activeLayer1 = 0;
        let activeLayer2 = 1;

        // ENERGY TRACKING
        let energyHistory = new Array(60).fill(0);
        let lastDrop = 0;

        function initAudio() {
            navigator.mediaDevices.getDisplayMedia({ video: true, audio: true }).then(stream => {
                try {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    audioCtx = new AC();
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 1024;
                    analyser.smoothingTimeConstant = CONFIG.smoothing;

                    const src = audioCtx.createMediaStreamSource(stream);
                    src.connect(analyser);
                    dataArray = new Uint8Array(analyser.frequencyBinCount);

                    document.getElementById('start-screen').style.opacity = 0;
                    setTimeout(() => document.getElementById('start-screen').style.display = 'none', 1000);
                    document.getElementById('post-card').style.opacity = 1;
                    document.getElementById('post-card').style.transform = "scale(1)";

                    isRunning = true;
                    startTime = Date.now();
                    reroll();
                    loop();
                } catch (e) { alert(e); }
            }).catch(e => alert("Audio Init Failed: " + e));
        }
        document.getElementById('start-btn').onclick = initAudio;

        // GL SETUP
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.onresize = resize;
        resize();

        function createShader(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
                return null;
            }
            return s;
        }
        const prog = gl.createProgram();
        gl.attachShader(prog, createShader(gl.VERTEX_SHADER, document.getElementById('vert').text));
        gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, document.getElementById('frag').text));
        gl.linkProgram(prog);
        gl.useProgram(prog);

        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        const aPos = gl.getAttribLocation(prog, "a_position");
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

        const uTime = gl.getUniformLocation(prog, "u_time");
        const uRes = gl.getUniformLocation(prog, "u_resolution");
        const uParams = gl.getUniformLocation(prog, "u_params");
        const uL1 = gl.getUniformLocation(prog, "u_layer1_type");
        const uL2 = gl.getUniformLocation(prog, "u_layer2_type");

        function reroll() {
            activeLayer1 = Math.floor(Math.random() * 8);
            do { activeLayer2 = Math.floor(Math.random() * 8); } while (activeLayer1 == activeLayer2);

            for (let i = 0; i < 16; i++) {
                paramMap[i] = Math.floor(Math.random() * 8);
            }

            const n1 = LAYERS[activeLayer1];
            const n2 = LAYERS[activeLayer2];
            const el = document.getElementById('layer-status');
            el.innerHTML = `NEURAL LINK: <span style="color:#0ff">${n1}</span> // <span style="color:#f0f">${n2}</span>`;
        }

        function loop() {
            if (!isRunning) return requestAnimationFrame(loop);

            const t = (Date.now() - startTime) * 0.001;
            analyser.getByteFrequencyData(dataArray);

            // Audio Processing
            let bands = new Float32Array(8);
            let binSize = Math.floor(dataArray.length / 8);
            // Linear binning is simpler for general "movement" visual
            for (let i = 0; i < 8; i++) {
                let sum = 0;
                for (let j = 0; j < binSize; j++) sum += dataArray[i * binSize + j];
                bands[i] = (sum / binSize) / 255.0;
            }

            // Drop Detection
            let energy = bands.reduce((a, b) => a + b) / 8;
            energyHistory.shift();
            energyHistory.push(energy);
            let avg = energyHistory.reduce((a, b) => a + b) / 60;

            if (Date.now() - lastDrop > 5000) {
                if (energy > avg * 1.5 && energy > 0.3) {
                    reroll();
                    lastDrop = Date.now();
                }
            }

            // Smooth
            let finalParams = new Float32Array(16);
            for (let i = 0; i < 8; i++)
                smoothedBands[i] += (bands[i] - smoothedBands[i]) * 0.1;

            for (let i = 0; i < 16; i++)
                finalParams[i] = smoothedBands[paramMap[i]];

            gl.uniform1f(uTime, t);
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1fv(uParams, finalParams);
            gl.uniform1i(uL1, activeLayer1);
            gl.uniform1i(uL2, activeLayer2);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(loop);
        }

        // FEED
        async function fetchFeed() {
            try {
                const didRes = await fetch(`${CONFIG.apiBase}/com.atproto.identity.resolveHandle?handle=${CONFIG.handle}`);
                const didData = await didRes.json();
                const feedRes = await fetch(`${CONFIG.apiBase}/app.bsky.feed.getAuthorFeed?actor=${didData.did}&limit=1`);
                const feedData = await feedRes.json();

                if (feedData.feed && feedData.feed.length > 0) {
                    const post = feedData.feed[0].post;
                    const txt = document.getElementById('post-text');
                    if (txt.innerText !== post.record.text) {
                        txt.innerText = post.record.text;
                        const d = new Date(post.record.createdAt);
                        document.getElementById('post-date').innerText = d.toLocaleTimeString() + " // LINK ESTABLISHED";
                    }
                    if (post.embed?.images?.[0]) {
                        document.getElementById('post-image').src = post.embed.images[0].fullsize;
                        document.getElementById('post-image').style.display = 'block';
                    }
                }
            } catch (e) { }
        }
        setInterval(fetchFeed, 10000);
        fetchFeed();

    </script>
</body>

</html>