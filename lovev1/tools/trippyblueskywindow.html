<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåÄ DMT Audio Reactive Feed - CRYSTAL VISION</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }

        canvas#glcanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #00e5ff;
            text-align: center;
            padding: 20px;
        }

        button {
            background: transparent;
            color: #00e5ff;
            border: 2px solid #00e5ff;
            padding: 15px 30px;
            font-size: 1.5rem;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s;
        }

        button:hover {
            background: #00e5ff;
            color: #000;
            box-shadow: 0 0 20px #00e5ff;
        }

        #post-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            width: 90%;
            max-width: 550px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 2rem;
            border-radius: 15px;
            color: #fff;
            opacity: 0;
            transition: opacity 1s;
        }

        .handle {
            color: #00e5ff;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(0, 229, 255, 0.3);
            padding-bottom: 5px;
        }

        .post-image {
            width: 100%;
            border-radius: 8px;
            margin-top: 15px;
        }

        #debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            color: Lime;
            z-index: 200;
            font-family: monospace;
            display: none;
        }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>
    <div id="start-overlay">
        <h1>üëÅÔ∏è OPEN YOUR MIND üëÅÔ∏è</h1>
        <p>16-Band Audio Reactive Engine</p>
        <button id="start-btn">INITIATE</button>
    </div>

    <div id="post-container">
        <div class="handle">@e-v-l-o-v-e.bsky.social</div>
        <div id="post-text">Connecting...</div>
        <img id="post-image" class="post-image" style="display:none" />
        <div id="post-date" style="margin-top: 10px; font-size: 0.8em; color: #aaa;"></div>
    </div>

    <div id="debug-panel">DEBUG MODE</div>

    <script id="fragShader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision highp float;
        #endif

        uniform float u_time;
        uniform vec2 u_resolution;
        uniform float u_mappedBands[16]; // Mapped effects
        uniform float u_rawBands[16];    // Raw energy
        uniform float u_energy;

        // HIGH CONTRAST PALETTE
        vec3 palette(float t) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 1.0, 1.0);
            vec3 d = vec3(0.263, 0.416, 0.557); // Classic psychedelic phase
            return a + b * cos(6.28318 * (c * t + d + u_time * 0.1));
        }

        // 2D Rotation
        mat2 rot(float a) {
            float s = sin(a), c = cos(a);
            return mat2(c, -s, s, c);
        }

        // Starburst / Light Beams
        float starburst(vec2 uv, float distinctness) {
            float angle = atan(uv.y, uv.x);
            float beams = sin(angle * 12.0 + u_time) * cos(angle * 7.0 - u_time * 2.0);
            beams = smoothstep(0.2, 1.0, beams); // Sharpen
            float d = length(uv);
            return beams * (0.05 / d) * distinctness;
        }

        // Hexagonal / Crystal Grid
        float hexGrid(vec2 uv, float scale) {
            uv *= scale;
            vec2 r = vec2(1.0, 1.732);
            vec2 h = r * 0.5;
            vec2 a = mod(uv, r) - h;
            vec2 b = mod(uv - h, r) - h;
            vec2 gv = length(a) < length(b) ? a : b;
            float d = length(gv);
            return smoothstep(0.48, 0.5, d); // Sharp edges
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
            vec2 uv0 = uv;
            vec3 finalColor = vec3(0.0);

            // 1. BACKGROUND: DEEP PULSING TUNNEL
            // Driven by Bass (Bands 0-3 mapped)
            float tunnelDepth = 0.5 + u_mappedBands[0] * 0.5;
            float r = length(uv);
            float theta = atan(uv.y, uv.x);
            float tunnelParam = 1.0 / (r + 0.1); // Inverse distance for tunnel
            vec3 bgCol = palette(tunnelParam * 0.2 + theta * 0.1 + u_time * 0.1);
            bgCol *= (tunnelParam * 0.3 * tunnelDepth); // Fade into distance
            finalColor += bgCol;

            // 2. MIDDLE: KALEIDOSCOPE MANDALA
            // Driven by Mids (Bands 4-11 mapped)
            vec2 kv = uv;
            float rotSpeed = 0.2 + u_mappedBands[5] * 0.5;
            kv *= rot(u_time * rotSpeed);
            
            // 6-fold Symmetry
            float angle = atan(kv.y, kv.x);
            float radius = length(kv);
            angle = abs(mod(angle, 3.14159/3.0) - 3.14159/6.0);
            kv = vec2(sin(angle), cos(angle)) * radius;

            // Fractal Iterations
            for(float i=0.0; i<3.0; i++) {
                kv = abs(kv) - 0.4;
                kv *= rot(u_time * 0.3 + u_mappedBands[6]);
                kv = abs(kv) - 0.2;
                float d = length(kv) * exp(-length(uv0));
                
                // Neon glow edges
                d = sin(d * 8.0 + u_time) / 8.0;
                d = abs(d);
                d = pow(0.01 / d, 1.2); // Sharp glow line
                
                vec3 col = palette(length(uv0) + i * 0.4 + u_time * 0.4);
                finalColor += col * d * (0.8 + u_mappedBands[8] * 0.5); // Boost on mids
            }

            // 3. FOREGROUND: LIGHT BEAMS & SPARKLES
            // Driven by Highs (Bands 12-15 mapped)
            
            // Light Beams (God Rays)
            vec2 beamUV = uv0 * rot(u_time * 0.1);
            float beams = starburst(beamUV, u_mappedBands[12] * 2.0); // Intensity from high-mid
            finalColor += vec3(0.8, 0.9, 1.0) * beams;

            // Diamond Sparkles
            // Grid of sharp points
            vec2 sparkUV = uv0 * 2.0;
            vec2 sparkGrid = fract(sparkUV) - 0.5;
            float sparkD = length(sparkGrid);
            float sparkles = 0.005 / max(sparkD, 0.001);
            sparkles *= smoothstep(0.8, 1.0, sin(u_time * 5.0 + floor(sparkUV.x)*10.0 + floor(sparkUV.y)*20.0));
            sparkles *= u_mappedBands[15] * 3.0; // Treble controlled
            finalColor += vec3(1.0) * sparkles;

            // 4. POST PROCESSING
            // High contrast, no murkiness
            // Vignette
            finalColor *= 1.2 - length(uv0) * 0.5;
            
            // Saturation boost
            vec3 gray = vec3(dot(finalColor, vec3(0.299, 0.587, 0.114)));
            finalColor = mix(gray, finalColor, 1.3); // +30% Saturation

            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>
    <script id="vertShader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
    </script>
    <script>
        // CONFIG
        const CONFIG = {
            handle: 'e-v-l-o-v-e.bsky.social',
            apiBase: 'https://public.api.bsky.app/xrpc',
            numBands: 16,
            smoothing: 0.03, // Much smoother / slower reaction
            remapCooldown: 5000
        };

        // AUDIO
        let audioCtx, analyser, dataArray;
        let audioBands = new Float32Array(16);
        let effectMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]; // Identity map initially
        let isRunning = false;
        let overallEnergy = 0;

        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048; // Higher res for better bass definition
                analyser.smoothingTimeConstant = 0.85; // Smoother input

                const src = audioCtx.createMediaStreamSource(stream);
                src.connect(analyser); // Connect to analyser
                // src.connect(audioCtx.destination); // Optional: Hear it too? No, feedback loop risk.

                dataArray = new Uint8Array(analyser.frequencyBinCount);

                document.getElementById('start-overlay').style.display = 'none';
                document.getElementById('post-container').style.opacity = 1;
                isRunning = true;

                stream.getVideoTracks()[0].onended = () => alert("Stream ended");
            } catch (e) {
                console.error(e);
                alert("Audio Init Failed: " + e.message);
            }
        }

        document.getElementById('start-btn').onclick = initAudio;

        // WEBGL
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.onresize = resize;
        resize();

        function createShader(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(s));
            }
            return s;
        }

        const prog = gl.createProgram();
        gl.attachShader(prog, createShader(gl.VERTEX_SHADER, document.getElementById('vertShader').text));
        gl.attachShader(prog, createShader(gl.FRAGMENT_SHADER, document.getElementById('fragShader').text));
        gl.linkProgram(prog);
        gl.useProgram(prog);

        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(prog, "a_position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const uTime = gl.getUniformLocation(prog, "u_time");
        const uRes = gl.getUniformLocation(prog, "u_resolution");
        const uMapped = gl.getUniformLocation(prog, "u_mappedBands");
        const uRaw = gl.getUniformLocation(prog, "u_rawBands");
        const uEnergy = gl.getUniformLocation(prog, "u_energy");

        function analyze() {
            if (!isRunning) return;
            analyser.getByteFrequencyData(dataArray);

            // Logarithmic binning for 16 bands
            let start = 0;
            let total = 0;
            for (let i = 0; i < 16; i++) {
                // Log scale: wider ranges for higher frequencies
                let width = Math.floor(Math.pow(1.4, i) * 2);
                let end = start + width;
                let sum = 0;
                let count = 0;
                for (let j = start; j < end && j < dataArray.length; j++) {
                    sum += dataArray[j];
                    count++;
                }
                let val = (count > 0 ? sum / count : 0) / 255.0;
                audioBands[i] += (val - audioBands[i]) * CONFIG.smoothing; // Smooth
                total += audioBands[i];
                start = end;
            }
            overallEnergy = total / 16.0;

            // Randomly shuffle map on big drops? (Optional, kept simple for now)
            if (overallEnergy > 0.8 && Math.random() < 0.01) {
                // Flash change
                // shuffle(effectMap);
            }
        }

        function loop(t) {
            analyze();

            // Map bands
            let mapped = new Float32Array(16);
            for (let i = 0; i < 16; i++) mapped[i] = audioBands[effectMap[i]];

            gl.uniform1f(uTime, t * 0.0002); // 5x Slower Animation Speed
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1f(uEnergy, overallEnergy);
            gl.uniform1fv(uMapped, mapped);
            gl.uniform1fv(uRaw, audioBands);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        // BLUESKY FEED (Simplified)
        async function fetchFeed() {
            try {
                const didRes = await fetch(`${CONFIG.apiBase}/com.atproto.identity.resolveHandle?handle=${CONFIG.handle}`);
                const didData = await didRes.json();
                const feedRes = await fetch(`${CONFIG.apiBase}/app.bsky.feed.getAuthorFeed?actor=${didData.did}&limit=1`);
                const feedData = await feedRes.json();

                if (feedData.feed && feedData.feed.length > 0) {
                    const post = feedData.feed[0].post;
                    document.getElementById('post-text').innerText = post.record.text;
                    document.getElementById('post-date').innerText = new Date(post.record.createdAt).toLocaleTimeString();

                    if (post.embed?.images?.[0]) {
                        const img = document.getElementById('post-image');
                        img.src = post.embed.images[0].fullsize;
                        img.style.display = 'block';
                    }
                }
            } catch (e) {
                console.log("BlueSky Poll Error", e);
            }
        }
        fetchFeed();
        setInterval(fetchFeed, 30000);

    </script>
</body>

</html>