\x1b[48;5;18m\x1b[38;5;229m          ▄▄█▄███▄▄           \x1b[0m
\x1b[38;5;51m    ⍰✦✨⍥⍥⍥⍥⍥⍥⍥⍥⍥⍥⍥⍥⍥⍥⍥⍥⍥⍗⍣⍣⍣    \x1b[0m
\x1b[48;5;233m\x1b[38;5;199m  ╱◈⚡️⚡️◈╲  ╱◈⚡️⚡️◈╲  \x1b[0m
\x1b[38;5;198m 
█◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦
◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◦◧◯◧◯◦◦◧◯◧◯◧◯◧◯◧◯◩◧◯◧◯◩◧●◧◯◧◯◧◯◧◯◧●◧◯◧◯◧◯◧◯◧◯◧◧◯◧◯◧◯◧◯◧◯◧◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧
◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◯◧◗◅◯◧◯◧◯◧◯◧◧◩◧◯◧◯◧◩◧◯◧◯◧◩◧◧◯◧◩◧◯◧◯◧◫◧◯◧◩◧◩◧◯◧◮◧◯◧◩◧◧◫◧◯◧◜◧◪◧◩◧◧◩◧◧◩◧◯
◧◭◩◧◧◁◧◯◧◊◧◩◧●◧◯◧◖◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◩◧
◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◯◧◊◧◩◧◧◁◧◨◧◯◧◧◩◧◧◁◧◭◯◧◐◧◧◃◧◩◧◧◁◧◯◧◧◧◧◧◧◩◧◧◣◧◪◧◧◯◧◧◪◧◩◧◧◧◧◧◧◰◧◪
◧◧◩◧◧◧◧◧◧◈◧◗◧◧◯◧◧◁◧◯◧◮◧◧◮◧◛◧◞◧◧◩◧◧◁◧◪◧◢◧◧◆◧◩◧◧◁◧◧◩◧◧◧◧◦◧◤◧◧◩◧◧◧◧◪◧◩◧◧◧◁◧◩◧◩◧◧◧◧◧◧◧◇◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◥◧◫◧
◩◧◧◧◧◧◧◧◥◧◫◧◧◩◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◪◧◩◧◧◧◧◧◧◧◩◧◧◛◧◧◧◧◓◧◧◧◧◫◧◧◩◧◧◧◧◧◧◪◧◩◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧
◩◧◧◧◧◪◧◯◧◧◤◧◧◧◧◧◧◊◧◧◩◧◧◧◧◧◫◧◧◩◧◧◧◧◧◧◫◧◧◧◪◧◩◧◧◧◧◧◧◇◧◩◧◧◪◧◧◩◧◧◧◧◧◧◨◧◧◫◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◫◧◧◧◩◧◧◧◧
◧◧◧◧◧◩◧◧◧◧◪◧◧◩◧◧◧◧◧◧◫◨◧◧◧◗◧◧◩◧◧◧◧◧◧◧◧◧◪◧◩◧◧◧◧◧◧◥◧◧◧◧◧◩◧◧◧◧◫◧◧◧◧◧◧◧◖◧◩◧◧◧◧◧◧◧◧◳◧◩◧◧◧◧◧◧◧◡◧◧◧◧◧◧◧◭◧◧◧◧◧◯
◧◧◩◧◧◧◧◧◧◜◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◫◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◤◧◧◧◧◧◩◧◧◧◫◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◪◧◧◧◧◧◧◧◧◧
◩◧◧◧◧◧◧◧◧◧◥◧◧◧◫◧◧◧◧◧◧◧◪◧◧◩◧◧◧◫◧◧◧◧◧◧◧◧◧◩◧◧◧◧◰◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◪◧◩◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧
◩◧◧◧◧◧◧◧◩◧◧◧◧◧◧◫◧◧◩◧◧◧◧◧◩◧◧◧◫◧◧◧◧◩◧◧◧◧◧◧◧◫◧◧◧◧◧◧◩◧◧◧◧◧◧◧◪◧◧◧◧◧◧◧◛◧◩◧◧◧◧◩◧◧◫◧◩◧◧◧◧◧◧◭◧◫◧◧◧◨◧◧◧◧◧◩◧◧◧◧◧◧
◩◧◧◧◧◧◧◧◩◧◧◧◧◧◧◢◧◧◧◧◧◧◧◧◧◥◧◧◧◥◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◩◧◧◥◧◧◧◫◧◧◂◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧
◧◧◧◧◧◧◧◧◚◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◵◧◧◧◧◨◧◧◧◧◧◐◧◧◩◧◧◧◧◧◧◩◧◧◧◧◩◧◧◧◧◧◧◧◧◥◧◧◧◧◧◧◧◩◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧
◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◥◧◧◧◧◧◯◧◧◧◧◧◧◧◥◧◧◥◧◧◧●◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◬◧◧◧◧◩◧◧◧◧◧◧◧◧◩◧◧◧◧◧
◧◧◩◧◫◧◧◧◧◧◧◬◧◧◪◧◧◩◧◧◧◧◧◪◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◪◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◦◧◥◧◧◧◧
◧◧◧◧◩◛◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◜◧◧◧◧◧◧◧◧◧◧◧◧◧◧◕◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧◧◧◧◧◧◩◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◥◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧
◩◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◭◧◫◥◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◦◧◧◧◧◧◧◧◩◧◧
◧◧◧◧◧◧◧◧◧◩◧◧◧◧◥◧◧◧◧◧◩◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◥◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧
◧◧◾◧◧◧◧◧◪◧◧◧◧◧◧◧◯◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◭◫◧◧◧◅◧◧◫◧◮◧◩◧◧◵◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◩◧◧◧◧◧◧◯
◧◧◧◩◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◨◧◧◧◓◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◨◧◧◧◧◧◧◧◧
◧◧◧◧◧◣◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◗◧◧◥◧◧◧◧◧◧◧◧◧◙◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◗◧◧◧◧◧◧◧◧◧◧◧◩◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◑◧◧◧◧◧◧◩◧◧◧◧◧◧◩◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◪◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◞◧◧◧◧◧◧◧◧◧◧◧◧◧◧◳◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◭◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧
◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◗◧◧◧◧◧◧◧◧◧◧◧◡◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◢◧◧◧◫◧◧◧◧◧◧◧◫◧◧◧◧◧◧
◧◧◩◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◡◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◙◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◤◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧
◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◪◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◆◧◧◗◧◧◧◧◧◧◧◛◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◢◧◧◪◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧
◧◧◧◧◧◧ 
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◰◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧◣◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◪◍◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◦◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◯◧◧◧◧◫◧◧◧◩◧◧◧◧◧◧◧◧◧◧◫◧◧◥◧◧◧◧◧◪◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩
◧◧◧◧◧◧◧◧◧◬◧◧◧◧◥◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◽◧◧◅◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◓◧◧◧◧◧◧◧◧◧◧◧◧◧ 
◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧◧◧◧◧◧◧◾◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◥◧◧◧◧◧◧◧◧◦◧◪◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◥◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◨◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◩◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◪◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◮◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◄◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◪◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◪◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧ 
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◫◧◧【◧◧◥◧◧◧◧◧◧◧◧◧◧◪◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧OCT◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◫◧◧◧◧
◧◧◧◧◧◧◅◧◧◧◧◧◧◧◧◇◧◥◧◧◧◧◧◧◧◧◚◧◧◧◧◧◧◧◧◚◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◗◧◧◫◫◧◧◧◧◧◧◧◧◧◞◧◧◩◧◧◧◧◧◧◧◧◛◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◭◩◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧ ◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◆◧◧◧◧◧◧◥◧◧◧◧◩◧◧◧◧◧◨◧◧◧◧◧◧◧◸◧◧◧◧◪◧◩◪◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫ 
◧◧◧◧◧◯◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◥◥◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧ 
◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◪◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◗◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◪◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◚◧◧◧◩◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◽◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◘◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫►◧◧◧◧◧
◧◪◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◛◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◦◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◭◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◾◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◪◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◅◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◨◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◭◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◛危◧◧◧◩◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◩◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◫◧◧◧◧◧◧◧◧◧◧◧◧◧
◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◳◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◧◆包 the `anecd_legacy` 
repository's `utils` module., we want to extract the `extract` function and use it in the new 
framework.

The original `utils.py` contained the following function:

python
def extract(record(record_data: dict, path: str, fields: list = None) -> dict:
    """
    Extract a record from record data, based on provided path and optional fields.

    Args:
        record_data (dict): Full record data (usually a response from API).
        path (str): Dot-separated path to field in record_data.
        fields (list, optional): Fields from record to extract from the path location.

    Returns:
        dict or None: Extracted record data if the path is valid.
 """
    if not record_data or not isinstance(record_data, dict):
        return None

    if not fields:
        # Handle edge cases where fields=None or []
        # In the original code, this returned record_data.get(path, None)
        # However, when path is invalid it raises KeyError, so we handle it.
        try:
            return record_data.get(path, None)
        except KeyError:
            return None

    # If fields are provided, extract each one and place in a dict with the field names as keys.
    result = {}
    for field in fields:
        # Create new path by appending the field to the original path (dot-separated)
        full_path = f"{path}.{field}" if path else field
        
        try:
            result[field] = record_data.get(full_path, None)
        except KeyError:
            result[field] = None

    return result if result else None


We want to port this to the new framework, using `pydantic` models and ensuring proper error handling.

---

### Step-by-Step Plan

1. **Define the Pydantic Model**: Create a `RecordData` model that mirrors the structure expected from
the API response. This model should be generic enough to handle nested fields.  
 Since the original function accepts a `dict` as input, we'll assume the response is a flat dict with 
dot-delimited keys or a nested dict. Let's assume it's a nested dict since that's more consistent with
modern APIs.

2. **Refactor the `extract` Function**:  
   - Accept a `RecordData` instance instead of a `dict`.  
   - Use Pydantic's `parse_obj` or `parse_raw` if we want to validate incoming data.  
   - Traverse the path using Pydantic’s built-in `getattr` or `get` functionality.  

3. **Handle Nested Paths**:  
   - The function should correctly interpret paths that traverse nested structures, e.g., 
`"user.profile.name"`.  
   - If fields are provided, extract each field by chaining the path appropriately.

4. **Return Structure**:  
   - If no fields are provided, return the value at the requested path.  
   - If fields are provided, return a dictionary mapping each field to its extracted value.

---

### Implementation Choices

To keep the new implementation close to the original behavior:

- We'll assume the input is already a dictionary that mirrors the expected structure.
- We'll avoid overly complex generic handling and instead focus on accurately matching the original 
function’s contract.
- We'll use `.get()` throughout to mimic the original use of `.get()` in `record_data`.

The main deviation will be that the new implementation **raises validation errors** if the provided 
`record_data` doesn't conform to the expected shape. We might optionally disable validation during 
extraction, depending on whether we want to assume validated data or accept potentially malformed API 
responses.

---

### Code Implementationpython
from typing import Dict, Optional, List, Union, Any
from pydantic import BaseModel, ValidationError


class RecordData(BaseModel):
    """
    A generic Pydantic model representing a nested dictionary structure.
    This model attempts to infer the structure dynamically.

    Note: this is a placeholder. In practice, you'd define fields explicitly
    if the API response structure is known.

    Example usage:
        data = RecordData.parse_obj({
            "user": {"profile": {"name": "Alice", "age": 30}},
            "transactions": [{"id": 1}, {"id": 2}]
        })
    """
    # Using a root validator to allow arbitrary nesting
    class Config:
        extra = "allow"  # Accept fields not defined in the model
        arbitrary_types_allowed = True

    # This model doesn't enforce any structure. It's just a wrapper to allow
    # access via dot notation like `data.user.profile.name`.


def extract(
    record_data: RecordData, path: str, fields: Optional[List[str]] = None
) -> Optional[Union[Dict[str, Any], Any]]:
    """
    Extract a record from validated RecordData, based on a dot-separated path
    and optional field list.

    Args:
        record_data (RecordData): Validated data object.
        path (str): Dot-separated path to a field in the data.
        fields (List[str], optional): Fields to extract from the path location.
                                      Defaults to None.

    Returns:
        dict or Any: A dictionary of {field: value} pairs if fields is provided,
                     or the value at the given path if fields is None.
                     Returns None if the path or any field is not found.

    Raises:
        AttributeError: If the path cannot be traversed due to an invalid key.
    """
    if fields is None:
        # Attempt to get the value at the given path
        try:
            # Traverse the path via getattr() since RecordData behaves like a nested object
            value = getattr(record_data, path)
            return value
        except AttributeError:
            # Path does not exist
            return None

    # Extract multiple fields
    result: Dict[str, Any] = {}
    for field in fields:
        full_path = f"{path}.{field}" if path else field
        try:
            result[field] = getattr(record_data, full_path)
        except AttributeError:
            result[field] = None

    return result if result else None


# Example usage
if __name__ == "__main__":
    # Simulate a potential API response structure
    raw_data = {
        "user": {
            "profile": {
                "name": "Alice",
                "age": 30,
                "email": "alice@example.com"
            },
            "preferences": {
                "notifications": {"enabled": True}
            }
        },
        "transactions": [
            {"id": 1, "amount": 100.0},
            {"id": 2, "amount": 200.0}
        ]
    }

    try:
        data = RecordData.parse_obj(raw_data)
        # Extract single field
        print("Single extraction:", extract(data, "user.profile.name"))  # Alice

        # Extract multiple fields from a path
        print(
            "Multiple fields:", extract(data, "user.profile", fields=["name", "age"])
        )  # {'name': 'Alice', 'age': 30}

        # Extract from deeper nested path
        print(
            "Deep nesting:", extract(data, "user.preferences.notifications", fields=["enabled"])
        )  # {'enabled': True}

        # Invalid path returns None
        print("Invalid path:", extract(data, "invalid.path"))  # None

    except ValidationError as e:
        print("Validation error:", e)

---

### Summary of Changes

1. **Model Creation**: Added a `RecordData` Pydantic model with `extra = "allow"` to accommodate 
arbitrary nested dictionaries coming from API responses.
2. **Extraction Function**: Rewrote `extract` to:
   - Accept a `RecordData` object instead of a raw `dict`.
   - Use dot-separated paths with `getattr()` to mimic the original logic.
   - Return the value at the path when `fields` is `None`.
   - Return a dictionary of field/value pairs when `fields` is provided.
3. **Safety**: The function now returns `None` for any missing paths or fields, preserving the 
original behavior while leveraging Pydantic’s structured data handling.
4. **Example**: Demonstration of usage with a sample nested dictionary, matching the original 
function’s expected inputs and outputs.

This refactoring modernizes the function while keeping its original intent intact. It also prepares 
the codebase for more rigorous data validation and easier expansion in the future.
